$NetBSD: patch-ae,v 1.2 1998/11/01 23:22:19 tron Exp $

Most of this file was taken from the xosview swapinternal.cc file.

--- sysdeps/bsd/swap.c	1998/10/06 16:52:26	1.1
+++ sysdeps/bsd/swap.c	1998/10/06 17:02:58
@@ -19,6 +19,54 @@
    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.  */
 
+/*  Copyright (c) 1995 by Brian Grayson (bgrayson@ece.utexas.edu)
+ *
+ *  This code is borrowed HEAVILY from the vmstat source code in the
+ *  NetBSD distribution.  As such, the NetBSD copyright claim/disclaimer
+ *  applies to most of this code.  The disclaimer, along with the CVS
+ *  header from the version from which this file was created, are included
+ *  below:
+ *
+ * Id: swapinternal.cc,v 1.15 1998/05/17 21:34:06 bgrayson Exp
+ *
+ *  NOTE THAT THIS FILE IS UNDER THE BSD COPYRIGHT, AND NOT GPL!
+ */
+
+/*      NetBSD: swap.c,v 1.4 1995/08/31 22:20:19 jtc Exp     */
+
+/*-
+ * Copyright (c) 1980, 1992, 1993
+ *      The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by the University of
+ *      California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
 #include <glibtop.h>
 #include <glibtop/error.h>
 #include <glibtop/swap.h>
@@ -27,141 +75,151 @@
 
 #include <glibtop_suid.h>
 
+#include <sys/types.h>
 #include <sys/conf.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#ifdef __FreeBSD__
 #include <sys/rlist.h>
+#else
+#include <sys/map.h>
+#endif
 #include <sys/vmmeter.h>
 
+/*---------------------  The remainder of this file is based/borrowed
+ *                       from /usr/src/bin/systat/swap.c in the NetBSD
+ *                       distribution.  Modifications will be
+ *                       bracketed by comment markers like these.  BCG
+ */
+
+/*
+ * swapinfo - based on a program of the same name by Kevin Lahey
+ */
+
+/*---------------------  Note:  all of these includes were in the
+ *		       original source code.  I am leaving them
+ *		       undisturbed, although it is likely that
+ *		       some may be removed, since lots of the swap
+ *		       code has been removed.  BCG  FIXME SOMEDAY
+ */
+
+#include <sys/param.h>
+/*---------------------  It appears buf.h is not needed, and
+ *			causes breakage on FreeBSD. */
+/*#include <sys/buf.h>*/
+#include <kvm.h>
+#include <nlist.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sys/cdefs.h>
+#include <fcntl.h>
+
+/* extern char *getbsize __P((int *headerlenp, long *printoutblocksizep)); */
+
+static int nswap, nswdev, dmmax;
+static struct swdevt *sw;
+static long *perdev;
+#ifdef __FreeBSD__
+static struct rlisthdr swaplist;
+#else
+static int nswapmap;
+static struct map *swapmap, *kswapmap;
+static struct mapent *mp;
+#endif
+static int nfree;
+
 static const unsigned long _glibtop_sysdeps_swap =
 (1 << GLIBTOP_SWAP_TOTAL) + (1 << GLIBTOP_SWAP_USED) +
 (1 << GLIBTOP_SWAP_FREE) + (1 << GLIBTOP_SWAP_PAGEIN) +
 (1 << GLIBTOP_SWAP_PAGEOUT);
 
 /* nlist structure for kernel access */
-static struct nlist nlst [] = {
-#define VM_SWAPLIST	0
-	{ "_swaplist" },/* list of free swap areas */
-#define VM_SWDEVT	1
+static struct nlist syms [] = {
+#define VM_SWDEVT	0
 	{ "_swdevt" },	/* list of swap devices and sizes */
-#define VM_NSWAP	2
+#define VM_NSWAP	1
 	{ "_nswap" },	/* size of largest swap device */
-#define VM_NSWDEV	3
+#define VM_NSWDEV	2
 	{ "_nswdev" },	/* number of swap devices */
-#define VM_DMMAX	4
+#define VM_DMMAX	3
 	{ "_dmmax" },	/* maximum size of a swap block */
+#ifdef __NetBSD__
+	{ "_swapmap" }, /* list of free swap areas */
+#define VM_SWAPMAP      4
+	{ "_nswapmap" },/* size of the swap map */
+#define VM_NSWAPMAP     5
+#else 
+	{ "_swaplist" },/* list of free swap areas */
+#define VM_SWAPLIST     4
+#endif /* !NetBSD */
 	{ 0 }
 };
 
-/* Init function. */
+#define SVAR(var) __STRING(var) /* to force expansion */
+#define KGET(idx, var) \
+        KGET1(idx, &var, sizeof(var), SVAR(var))
+#define KGET1(idx, p, s, msg) \
+	KGET2(syms[idx].n_value, p, s, msg)
+#define KGET2(addr, p, s, msg) \
+	if (kvm_read(server->machine.kd, addr, p, s) != s) { \
+		glibtop_error_io_r(server, "cannot read %s: %s", msg, kvm_geterr(server->machine.kd)); \
+		return (0); \
+	}
 
-void
-glibtop_init_swap_p (glibtop *server)
+
+static int
+BSDInitSwapInfo(glibtop *server)
 {
-	server->sysdeps.swap = _glibtop_sysdeps_swap;
+        static int once = 0;
+        u_long ptr;
 
-	if (kvm_nlist (server->machine.kd, nlst) != 0)
-		glibtop_error_io_r (server, "kvm_nlist");
+	(void) ptr;	/*  Avoid gcc warnings. */
+        if (once)
+                return (1);
+        if (kvm_nlist(server->machine.kd, syms)) {
+                return (0);
+        }
+        KGET(VM_NSWAP, nswap);
+        KGET(VM_NSWDEV, nswdev);
+        KGET(VM_DMMAX, dmmax);
+#ifdef __FreeBSD__
+	sw = glibtop_malloc_r (server, nswdev * sizeof(*sw));
+	perdev = glibtop_malloc_r (server, nswdev * sizeof(*perdev));
+	KGET1(VM_SWDEVT, &ptr, sizeof ptr, "swdevt");
+	KGET2(ptr, sw, (signed) (nswdev * sizeof(*sw)), "*swdevt");
+#else /* __FreeBSD__ */
+        KGET(VM_NSWAPMAP, nswapmap);
+        KGET(VM_SWAPMAP, kswapmap);     /* kernel `swapmap' is a pointer */
+	sw = glibtop_malloc_r (server, nswdev * sizeof(*sw));
+	perdev = glibtop_malloc_r (server, nswdev * sizeof(*perdev));
+	mp = glibtop_malloc_r(server, nswapmap * sizeof(*mp));
+        KGET1(VM_SWDEVT, sw, (signed) (nswdev * sizeof(*sw)), "swdevt");
+#endif /* __FreeBSD__ */
+        once = 1;
+        return (1);
 }
 
-/* Provides information about swap usage. */
-
-/*
- * This function is based on a program called swapinfo written
- * by Kevin Lahey <kml@rokkaku.atl.ga.us>.
- */
-
-void
-glibtop_get_swap_p (glibtop *server, glibtop_swap *buf)
+#ifdef __FreeBSD__
+/* Taken verbatim from /usr/src/usr.bin/systat/swap.c (pavel 24-Jan-1998) */
+int
+fetchswap(glibtop *server)
 {
-	char *header;
-	int hlen, nswap, nswdev, dmmax;
-	int i, div, avail, nfree, npfree, used;
-	struct swdevt *sw;
-	long blocksize, *perdev;
 	struct rlist head;
-	struct rlisthdr swaplist;
 	struct rlist *swapptr;
-	size_t sw_size;
-	u_long ptr;
-
-	/* To get `pagein' and `pageout'. */
-	struct vmmeter vmm;
-        static int swappgsin = -1;
-	static int swappgsout = -1;
-
-	glibtop_init_p (server, (1 << GLIBTOP_SYSDEPS_SWAP), 0);
-	
-	memset (buf, 0, sizeof (glibtop_swap));
-
-	/* This is used to get the `pagein' and `pageout' members. */
-	
-	if (kvm_read (server->machine.kd, nlst[0].n_value,
-		      &vmm, sizeof (vmm)) != sizeof (vmm))
-		glibtop_error_io_r (server, "kvm_read (cnt)");
-	
-        if (swappgsin < 0) {
-		buf->pagein = 0;
-		buf->pageout = 0;
-	} else {
-		buf->pagein = vmm.v_swappgsin - swappgsin;
-		buf->pageout = vmm.v_swappgsout - swappgsout;
-	}
-
-        swappgsin = vmm.v_swappgsin;
-	swappgsout = vmm.v_swappgsout;
-
-	/* Size of largest swap device. */
-
-	if (kvm_read (server->machine.kd, nlst[VM_NSWAP].n_value,
-		      &nswap, sizeof (nswap)) != sizeof (nswap))
-		glibtop_error_io_r (server, "kvm_read (nswap)");
-
-	/* Number of swap devices. */
-
-	if (kvm_read (server->machine.kd, nlst[VM_NSWDEV].n_value,
-		      &nswdev, sizeof (nswdev)) != sizeof (nswdev))
-		glibtop_error_io_r (server, "kvm_read (nswdev)");
-
-	/* Maximum size of a swap block. */
-
-	if (kvm_read (server->machine.kd, nlst[VM_DMMAX].n_value,
-		      &dmmax, sizeof (dmmax)) != sizeof (dmmax))
-		glibtop_error_io_r (server, "kvm_read (dmmax)");
-
-	/* List of free swap areas. */
-
-	if (kvm_read (server->machine.kd, nlst[VM_SWAPLIST].n_value,
-		      &swaplist, sizeof (swaplist)) != sizeof (swaplist))
-		glibtop_error_io_r (server, "kvm_read (swaplist)");
-
-	/* Kernel offset of list of swap devices and sizes. */
-
-	if (kvm_read (server->machine.kd, nlst[VM_SWDEVT].n_value,
-		      &ptr, sizeof (ptr)) != sizeof (ptr))
-		glibtop_error_io_r (server, "kvm_read (swaplist)");
-
-	/* List of swap devices and sizes. */
-
-	sw_size = nswdev * sizeof (*sw);
-	sw = glibtop_malloc_r (server, sw_size);
-
-	if (kvm_read (server->machine.kd, ptr, sw, sw_size) != sw_size)
-		glibtop_error_io_r (server, "kvm_read (*swdevt)");
-
-	perdev = glibtop_malloc (nswdev * sizeof (*perdev));
 
 	/* Count up swap space. */
-
 	nfree = 0;
-	memset (perdev, 0, nswdev * sizeof(*perdev));
-
+	memset(perdev, 0, nswdev * sizeof(*perdev));
+	KGET1(VM_SWAPLIST, &swaplist, sizeof swaplist, "swaplist");
 	swapptr = swaplist.rlh_list;
-
 	while (swapptr) {
 		int	top, bottom, next_block;
 
-		if (kvm_read (server->machine.kd, (int) swapptr, &head,
-			      sizeof (struct rlist)) != sizeof (struct rlist))
-			glibtop_error_io_r (server, "kvm_read (swapptr)");
+		KGET2((unsigned long)swapptr, &head,
+		      sizeof(struct rlist), "swapptr");
 
 		top = head.rl_end;
 		bottom = head.rl_start;
@@ -191,43 +249,136 @@
 
 		swapptr = head.rl_next;
 	}
+	return 0;
 
-	header = getbsize (&hlen, &blocksize);
+}
+#else /* __FreeBSD__ */
+void
+fetchswap(glibtop *server)
+{
+        int s, e, i;
+        int elast;
+	struct mapent* localmp;
+
+	localmp = mp;
+        s = nswapmap * sizeof(*localmp);
+        if (kvm_read(server->machine.kd, (long)kswapmap, localmp, s) != s)
+                glibtop_error_io_r(server, "cannot read swapmap: %s", kvm_geterr(server->machine.kd));
+
+        /* first entry in map is `struct map'; rest are mapent's */
+        swapmap = (struct map *)localmp;
+	if (!swapmap) {
+	  glibtop_error_io_r(server, "Error:  swapmap appears to be %p", swapmap);
+	}
+        if (nswapmap != swapmap->m_limit - (struct mapent *)kswapmap)
+                glibtop_error_io_r(server, "panic: swap: nswapmap goof");
 
-	div = blocksize / 512;
-	avail = npfree = 0;
-	for (i = 0; i < nswdev; i++) {
-		int xsize, xfree;
+        /*
+         * Count up swap space.
+         */
+        nfree = 0;
+        elast = 0;
+        bzero(perdev, nswdev * sizeof(*perdev));
+        for (localmp++; localmp->m_addr != 0; localmp++) {
+                s = localmp->m_addr;                 /* start of swap region */
+                e = localmp->m_addr + localmp->m_size;    /* end of region */
+                elast = e;
+                nfree += localmp->m_size;
+
+                /*
+                 * Swap space is split up among the configured disks.
+                 * The first dmmax blocks of swap space some from the
+                 * first disk, the next dmmax blocks from the next,
+                 * and so on.  The list of free space joins adjacent
+                 * free blocks, ignoring device boundries.  If we want
+                 * to keep track of this information per device, we'll
+                 * just have to extract it ourselves.
+                 */
+
+                /* calculate first device on which this falls */
+                i = (s / dmmax) % nswdev;
+                while (s < e) {         /* XXX this is inefficient */
+                        int bound = roundup(s + 1, dmmax);
+
+                        if (bound > e)
+                                bound = e;
+                        perdev[i] += bound - s;
+                        if (++i >= nswdev)
+                                i = 0;
+                        s = bound;
+                }
+        }
+}
+#endif /* __FreeBSD__ */
 
-		/*
-		 * Don't report statistics for partitions which have not
-		 * yet been activated via swapon(8).
-		 */
-		if (!(sw[i].sw_flags & SW_FREED))
-			continue;
+static void
+BSDGetSwapInfo(glibtop *server, glibtop_swap *buf)
+{
+        int i, avail, npfree, xsize, xfree;
 
-		/* The first dmmax is never allocated to avoid trashing of
-		 * disklabels
-		 */
-		xsize = sw[i].sw_nblks - dmmax;
+	fetchswap(server);
+        avail = npfree = buf->used = buf->pagein = buf->pageout = 0;
+        for (i = 0; i < nswdev; i++) {
+                /*
+                 * Don't report statistics for partitions which have not
+                 * yet been activated via swapon(8).
+                 */
+                if (!sw[i].sw_freed) {
+			/* -----  Originally, this printed a
+			 * warning.  However, for xosview, we
+			 * don't want the warning printed.
+			 * bgrayson  */
+                        continue;
+                }
+#ifdef __FreeBSD__
+                /*
+                 * The first dmmax is never allocated to avoid trashing of
+                 * disklabels
+                 */
+                /*xsize = sw[i].sw_nblks - dmmax;*/
+		/*  Actually, count those dmmax blocks -- pstat,
+		 *  top, etc. do.  It is swap space that is not
+		 *  free for use.  bgrayson, on suggestion from
+		 *  Andrew Sharp.  */
+                xsize = sw[i].sw_nblks;
+#else
+                xsize = sw[i].sw_nblks;
+#endif /* __FreeBSD__ */
 		xfree = perdev[i];
-		used = xsize - xfree;
-		npfree++;
-		avail += xsize;
-	}
+                buf->used = xsize - xfree;
+                npfree++;
+                avail += xsize;
+        }
+        /*
+         * If only one partition has been set up via swapon(8), we don't
+         * need to bother with totals.
+         */
+        if (npfree > 1) {
+                buf->used = avail - nfree;
+        }
+	  /*  Convert from 512-byte blocks to bytes.  */
+        buf->total = 512*avail;
+        buf->free = 512*(avail-buf->used);
+}
 
-	/*
-	 * If only one partition has been set up via swapon(8), we don't
-	 * need to bother with totals.
-	 */
-	used = avail - nfree;
+/* Provides information about swap usage. */
 
-	glibtop_free_r (server, sw);
-	glibtop_free_r (server, perdev);
+/*
+ * This function is based on a program called swapinfo written
+ * by Kevin Lahey <kml@rokkaku.atl.ga.us>.
+ */
+void
+glibtop_init_swap_p(glibtop *server)
+{
+	server->sysdeps.swap = _glibtop_sysdeps_swap;
 
-	buf->used = used;
-	buf->free = avail;
+	if (kvm_nlist (server->machine.kd, syms) != 0)
+		glibtop_error_io_r (server, "kvm_nlist");
+	BSDInitSwapInfo(server);
+}
 
-	buf->total = used + avail;
-	buf->flags = _glibtop_sysdeps_swap;
+void
+glibtop_get_swap_p (glibtop *server, glibtop_swap *buf)
+{
+	BSDGetSwapInfo(server, buf);
 }
