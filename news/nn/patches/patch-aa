$NetBSD: patch-aa,v 1.4 1998/08/07 11:11:10 agc Exp $

*** account.c.orig	Thu Sep 23 06:10:59 1993
--- account.c	Sat Apr 15 04:57:47 1995
***************
*** 43,49 ****
  extern int errno;
  
  struct account {
!     off_t ac_offset;	/* offset in acct file */
      int ac_found;	/* present in acct file */
      
      char ac_user[24];	/* user name */
--- 43,49 ----
  extern int errno;
  
  struct account {
!     long ac_offset;    /* offset in acct file */
      int ac_found;	/* present in acct file */
      
      char ac_user[24];	/* user name */
***************
*** 240,246 ****
      if (ac->ac_found)
  	fseek(acctf, ac->ac_offset, 0);
      else
! 	fseek(acctf, (off_t)0, 2);
      
      fprintf(acctf, OUTPUT_FMT, 
  	    ac->ac_user, ac->ac_total, ac->ac_last,
--- 240,246 ----
      if (ac->ac_found)
  	fseek(acctf, ac->ac_offset, 0);
      else
! 	fseek(acctf, (long)0, 2);
      
      fprintf(acctf, OUTPUT_FMT, 
  	    ac->ac_user, ac->ac_total, ac->ac_last,
*** active.c.orig	Sun Aug 15 10:59:33 1993
--- active.c	Sat Apr 15 04:57:47 1995
***************
*** 116,122 ****
  		    continue;
  	    } else {
  		gh->master_flag |= M_ALIASED | M_IGNORE_A;
! 		gh->data_write_offset = (off_t)gh1->group_num;
  	    }
  	    must_update = 1;
  	    break;
--- 116,122 ----
  		    continue;
  	    } else {
  		gh->master_flag |= M_ALIASED | M_IGNORE_A;
! 		gh->data_write_offset = (long)gh1->group_num;
  	    }
  	    must_update = 1;
  	    break;
*** admin.c.orig	Mon Sep 13 21:42:00 1993
--- admin.c	Sat Apr 15 04:57:48 1995
***************
*** 290,296 ****
  group_header *gh;
  {
      FILE *data, *ix;
!     off_t data_offset, next_offset;
      cross_post_number cross_post;
      article_number cur_article;
      int n, err_type;
--- 290,296 ----
  group_header *gh;
  {
      FILE *data, *ix;
!     long data_offset, next_offset;
      cross_post_number cross_post;
      article_number cur_article;
      int n, err_type;
***************
*** 453,459 ****
  group_header *gh;
  {
      FILE *data, *ix;
!     off_t offset;
      cross_post_number cross_post;
      article_number first_article;
      int n;
--- 453,459 ----
  group_header *gh;
  {
      FILE *data, *ix;
!     long offset;
      cross_post_number cross_post;
      article_number first_article;
      int n;
*** articles.c.orig	Fri Feb 18 05:15:47 1994
--- articles.c	Sat Apr 15 04:57:48 1995
***************
*** 259,265 ****
      int dbstatus;
  #else /* NOV */
      FILE *data;
!     off_t data_offset, data_size;
  #endif /* NOV */
      cross_post_number cross_post;
      attr_type leave_attr;
--- 259,265 ----
      int dbstatus;
  #else /* NOV */
      FILE *data;
!     long data_offset, data_size;
  #endif /* NOV */
      cross_post_number cross_post;
      attr_type leave_attr;
***************
*** 281,287 ****
      data = open_data_file(gh, 'd', OPEN_READ);
      if (data == NULL) return -10;
  
!     if ((data_offset = get_data_offset(gh, first_article)) == (off_t)(-1))
  	return -11;
  #endif /* NOV */
  
--- 281,287 ----
      data = open_data_file(gh, 'd', OPEN_READ);
      if (data == NULL) return -10;
  
!     if ((data_offset = get_data_offset(gh, first_article)) == (long)(-1))
  	return -11;
  #endif /* NOV */
  
***************
*** 350,356 ****
  	}
  	data_offset += data_size;
  #endif /* NOV */
! 	if (db_hdr.dh_lpos == (off_t)0)
  	    continue;	/* article not accessible */
  
  	if (db_hdr.dh_number > gh->last_db_article
--- 350,356 ----
  	}
  	data_offset += data_size;
  #endif /* NOV */
! 	if (db_hdr.dh_lpos == (long)0)
  	    continue;	/* article not accessible */
  
  	if (db_hdr.dh_number > gh->last_db_article
***************
*** 413,419 ****
  	}
  
  	ah->hpos = db_hdr.dh_hpos;
! 	ah->fpos = ah->hpos + (off_t)(db_hdr.dh_fpos);
  	ah->lpos = db_hdr.dh_lpos;
  
  	ah->attr = test_article(ah);
--- 413,419 ----
  	}
  
  	ah->hpos = db_hdr.dh_hpos;
! 	ah->fpos = ah->hpos + (long)(db_hdr.dh_fpos);
  	ah->lpos = db_hdr.dh_lpos;
  
  	ah->attr = test_article(ah);
*** chset.c.orig	Fri Mar 12 08:35:13 1993
--- chset.c	Sat Apr 15 04:57:48 1995
***************
*** 18,23 ****
--- 18,24 ----
      "iso-8859-7",	8,
      "iso-8859-8",	8,
      "iso-8859-9",	8,
+     "koi8-r",           8,
      "unknown",		0,
      NULL,		0,
  };
*** collect.c.orig	Wed Sep  1 01:05:31 1993
--- collect.c	Sat Apr 15 04:57:49 1995
***************
*** 45,51 ****
      article_number last;
      register FILE *arc;
      register int c;
!     off_t start;
      static char *arc_header = "Archived-Last: ";
      /* Header format: Archived-Last: 88888888 group.name */
      /* Fixed constants length == 15 and offset == 24 are used below */
--- 45,51 ----
      article_number last;
      register FILE *arc;
      register int c;
!     long start;
      static char *arc_header = "Archived-Last: ";
      /* Header format: Archived-Last: 88888888 group.name */
      /* Fixed constants length == 15 and offset == 24 are used below */
***************
*** 84,92 ****
  
      fseek(arc, start, 0);
      fprintf(arc, "%s%8ld %s\n", arc_header, (long)num, gh->group_name);
!     fseek(arc, (off_t)0, 2);
  
!     fseek(f, (off_t)0, 0);
      while ((c = getc(f)) != EOF) putc(c, arc);
      putc(NL, arc);
      fclose(arc);
--- 84,92 ----
  
      fseek(arc, start, 0);
      fprintf(arc, "%s%8ld %s\n", arc_header, (long)num, gh->group_name);
!     fseek(arc, (long)0, 2);
  
!     fseek(f, (long)0, 0);
      while ((c = getc(f)) != EOF) putc(c, arc);
      putc(NL, arc);
      fclose(arc);
***************
*** 178,185 ****
      /* get article header */
  
      art_hdr.a_number = art_num;
!     art_hdr.hpos = (off_t)0;
!     art_hdr.lpos = (off_t)0;
      art_hdr.flag = 0;
  
      mode = FILL_NEWS_HEADER | FILL_OFFSETS | SKIP_HEADER;
--- 178,185 ----
      /* get article header */
  
      art_hdr.a_number = art_num;
!     art_hdr.hpos = (long)0;
!     art_hdr.lpos = (long)0;
      art_hdr.flag = 0;
  
      mode = FILL_NEWS_HEADER | FILL_OFFSETS | SKIP_HEADER;
***************
*** 392,398 ****
  	}
  #endif
  #ifndef RENUMBER_DANGER
! 	if (temp == 0 && gh->data_write_offset == (off_t)0) {
  	    gh->first_db_article = gh->last_db_article + 1;
  	    continue;
  	}
--- 392,398 ----
  	}
  #endif
  #ifndef RENUMBER_DANGER
! 	if (temp == 0 && gh->data_write_offset == (long)0) {
  	    gh->first_db_article = gh->last_db_article + 1;
  	    continue;
  	}
*** data.h.orig	Sun Aug 15 10:59:43 1993
--- data.h	Sat Apr 15 04:57:49 1995
***************
*** 29,35 ****
      char		db_lock[DB_LOCK_MESSAGE];
      time_t		db_created; /* when database was last built */
      time_t		last_scan; /* age of active file at last scan */
!     off_t		last_size; /* size of active file at last scan */
      group_number	number_of_groups;
      int			free_groups;
  } master_header;
--- 29,35 ----
      char		db_lock[DB_LOCK_MESSAGE];
      time_t		db_created; /* when database was last built */
      time_t		last_scan; /* age of active file at last scan */
!     long                last_size; /* size of active file at last scan */
      group_number	number_of_groups;
      int			free_groups;
  } master_header;
***************
*** 68,75 ****
      article_number	first_a_article; /* min article in active */
      article_number	last_a_article;  /* max article in active */
  
!     off_t		index_write_offset;
!     off_t		data_write_offset;
  
      time_t		creation_time; /* when group was created */
  
--- 68,75 ----
      article_number	first_a_article; /* min article in active */
      article_number	last_a_article;  /* max article in active */
  
!     long                index_write_offset;
!     long                data_write_offset;
  
      time_t		creation_time; /* when group was created */
  
***************
*** 145,153 ****
      group_header *a_group;	/* if merged article menu	*/
  
  				/* indexes to header line text	*/
!     off_t	hpos;		/* first byte of header		*/
!     off_t	fpos;		/* first byte in article text	*/
!     off_t	lpos;		/* last pos of article		*/
  
      time_stamp 	t_stamp;	/* encoded time_stamp		*/
      time_stamp 	root_t_stamp;	/* subject's time_stamp		*/
--- 145,153 ----
      group_header *a_group;	/* if merged article menu	*/
  
  				/* indexes to header line text	*/
!     long        hpos;           /* first byte of header         */
!     long        fpos;           /* first byte in article text   */
!     long        lpos;           /* last pos of article          */
  
      time_stamp 	t_stamp;	/* encoded time_stamp		*/
      time_stamp 	root_t_stamp;	/* subject's time_stamp		*/
*** db.c.orig	Thu Nov 25 12:39:33 1993
--- db.c	Sat Apr 15 04:57:49 1995
***************
*** 1055,1061 ****
  
      if (!db_sequential)
  	fseek(master_file,
! 	      (off_t)(MASTER_FIELDS * sizeof(net_long) + DB_LOCK_MESSAGE +
  	      GROUP_FIELDS * sizeof(net_long) * gh->group_num), 0);
  
      if (fread((char *)buf, sizeof(net_long), GROUP_FIELDS, master_file) != GROUP_FIELDS)
--- 1055,1061 ----
  
      if (!db_sequential)
  	fseek(master_file,
! 	      (long)(MASTER_FIELDS * sizeof(net_long) + DB_LOCK_MESSAGE +
  	      GROUP_FIELDS * sizeof(net_long) * gh->group_num), 0);
  
      if (fread((char *)buf, sizeof(net_long), GROUP_FIELDS, master_file) != GROUP_FIELDS)
***************
*** 1075,1081 ****
  #else
      if (!db_sequential)
  	fseek(master_file, 
! 	      (off_t)(sizeof(master_header) + SAVED_GROUP_HEADER_SIZE(*gh) * gh->group_num), 0);
  
      if (fread((char *)gh, SAVED_GROUP_HEADER_SIZE(*gh), 1, master_file) != 1)
  	goto err;
--- 1075,1081 ----
  #else
      if (!db_sequential)
  	fseek(master_file, 
! 	      (long)(sizeof(master_header) + SAVED_GROUP_HEADER_SIZE(*gh) * gh->group_num), 0);
  
      if (fread((char *)gh, SAVED_GROUP_HEADER_SIZE(*gh), 1, master_file) != 1)
  	goto err;
***************
*** 1097,1103 ****
  
      if (!db_sequential)
  	fseek(master_file,
! 	      (off_t)(MASTER_FIELDS * sizeof(net_long) + DB_LOCK_MESSAGE +
  	      GROUP_FIELDS * sizeof(net_long) * gh->group_num), 0);
  
      buf[0] = gh->first_db_article;
--- 1097,1103 ----
  
      if (!db_sequential)
  	fseek(master_file,
! 	      (long)(MASTER_FIELDS * sizeof(net_long) + DB_LOCK_MESSAGE +
  	      GROUP_FIELDS * sizeof(net_long) * gh->group_num), 0);
  
      buf[0] = gh->first_db_article;
***************
*** 1115,1121 ****
  	goto err;
  #else
      if (!db_sequential)
! 	fseek(master_file, (off_t)(sizeof(master_header) + SAVED_GROUP_HEADER_SIZE(*gh) * gh->group_num), 0);
  
  
      if (fwrite((char *)gh, SAVED_GROUP_HEADER_SIZE(*gh), 1, master_file) != 1)
--- 1115,1121 ----
  	goto err;
  #else
      if (!db_sequential)
! 	fseek(master_file, (long)(sizeof(master_header) + SAVED_GROUP_HEADER_SIZE(*gh) * gh->group_num), 0);
  
  
      if (fwrite((char *)gh, SAVED_GROUP_HEADER_SIZE(*gh), 1, master_file) != 1)
***************
*** 1188,1197 ****
  
  
  #ifndef NOV
! off_t db_read_art(f)
  FILE *f;
  {
!     off_t bytes;
  
  #ifdef NETWORK_DATABASE
      net_long buf[ARTICLE_FIELDS];
--- 1188,1197 ----
  
  
  #ifndef NOV
! long db_read_art(f)
  FILE *f;
  {
!     long bytes;
  
  #ifdef NETWORK_DATABASE
      net_long buf[ARTICLE_FIELDS];
***************
*** 1368,1374 ****
   * fill in db_hdr and db_data from the overview data for the next
   * article in this group.  does weirdo nn encodings of header fields.
   */
! off_t
  db_read_art(f)
  FILE *f;
  {
--- 1368,1374 ----
   * fill in db_hdr and db_data from the overview data for the next
   * article in this group.  does weirdo nn encodings of header fields.
   */
! long
  db_read_art(f)
  FILE *f;
  {
***************
*** 1564,1595 ****
  }
  
  
! off_t get_index_offset(gh, art_num)
  group_header *gh;
  article_number art_num;
  {
  #ifdef NETWORK_DATABASE
!     return (off_t)((art_num - gh->first_db_article) * sizeof(net_long));
  #else
!     return (off_t)((art_num - gh->first_db_article) * sizeof(off_t));
  #endif
  }
  
! off_t get_data_offset(gh, art_num)
  group_header *gh;
  article_number art_num;
  {
      FILE *index;
!     off_t data_offset;
  
!     if (gh->first_db_article == art_num) return (off_t)0;
  
      index = open_data_file(gh, 'x', OPEN_READ);
!     if (index == NULL) return (off_t)(-1);
  
      fseek(index, get_index_offset(gh, art_num), 0);
      if (!db_read_offset(index, &data_offset))
! 	data_offset = (off_t)(-1);
  
      fclose(index);
  
--- 1564,1595 ----
  }
  
  
! long get_index_offset(gh, art_num)
  group_header *gh;
  article_number art_num;
  {
  #ifdef NETWORK_DATABASE
!     return (long)((art_num - gh->first_db_article) * sizeof(net_long));
  #else
!     return (long)((art_num - gh->first_db_article) * sizeof(long));
  #endif
  }
  
! long get_data_offset(gh, art_num)
  group_header *gh;
  article_number art_num;
  {
      FILE *index;
!     long data_offset;
  
!     if (gh->first_db_article == art_num) return (long)0;
  
      index = open_data_file(gh, 'x', OPEN_READ);
!     if (index == NULL) return (long)(-1);
  
      fseek(index, get_index_offset(gh, art_num), 0);
      if (!db_read_offset(index, &data_offset))
! 	data_offset = (long)(-1);
  
      fclose(index);
  
***************
*** 1600,1606 ****
  int
  db_read_offset(f, offset)
  FILE *f;
! off_t *offset;
  {
  #ifdef NETWORK_DATABASE
      net_long temp;
--- 1600,1606 ----
  int
  db_read_offset(f, offset)
  FILE *f;
! long *offset;
  {
  #ifdef NETWORK_DATABASE
      net_long temp;
***************
*** 1613,1619 ****
      *offset = temp;
  #else
  
!     if (fread((char *)offset, sizeof(off_t), 1, f) != 1) return 0;
  #endif
      return 1;
  }
--- 1613,1619 ----
      *offset = temp;
  #else
  
!     if (fread((char *)offset, sizeof(long), 1, f) != 1) return 0;
  #endif
      return 1;
  }
***************
*** 1621,1627 ****
  int
  db_write_offset(f, offset)
  FILE *f;
! off_t *offset;
  {
  #ifdef NETWORK_DATABASE
      net_long temp;
--- 1621,1627 ----
  int
  db_write_offset(f, offset)
  FILE *f;
! long *offset;
  {
  #ifdef NETWORK_DATABASE
      net_long temp;
***************
*** 1635,1641 ****
  
  #else
  
!     if (fwrite((char *)offset, sizeof(off_t), 1, f) != 1) return 0;
  #endif
      return 1;
  }
--- 1635,1641 ----
  
  #else
  
!     if (fwrite((char *)offset, sizeof(long), 1, f) != 1) return 0;
  #endif
      return 1;
  }
***************
*** 1659,1665 ****
  int
  db_read_offset(f, offset)
  FILE *f;
! off_t *offset;
  {
    nn_exitmsg(50, "STUB ROUTINE CALLED: db_read_offset\n");
    return -1;
--- 1659,1665 ----
  int
  db_read_offset(f, offset)
  FILE *f;
! long *offset;
  {
    nn_exitmsg(50, "STUB ROUTINE CALLED: db_read_offset\n");
    return -1;
***************
*** 1683,1689 ****
    return NULL;
  }
  
! off_t
  get_index_offset(gh, art_num)
  group_header *gh;
  article_number art_num;
--- 1683,1689 ----
    return NULL;
  }
  
! long
  get_index_offset(gh, art_num)
  group_header *gh;
  article_number art_num;
*** db.h.orig	Sun Aug 15 10:59:46 1993
--- db.h	Sat Apr 15 04:57:50 1995
***************
*** 71,78 ****
  
      time_stamp	dh_date; /* encoded Date: filed (not a time_t value!!) */
  
!     off_t	dh_hpos; /* absolute offset for first byte of header */
!     off_t	dh_lpos; /* absolute offset for last byte of article */
      int16	dh_fpos; /* relative offset for first byte in article text */
  
      int16	dh_lines;
--- 71,78 ----
  
      time_stamp	dh_date; /* encoded Date: filed (not a time_t value!!) */
  
!     long        dh_hpos; /* absolute offset for first byte of header */
!     long        dh_lpos; /* absolute offset for last byte of article */
      int16	dh_fpos; /* relative offset for first byte in article text */
  
      int16	dh_lines;
***************
*** 104,111 ****
  
  /* data access */
  
! off_t db_read_art();
! off_t get_index_offset(), get_data_offset();
  
  extern data_header db_hdr;
  extern data_dynamic_data db_data;
--- 104,111 ----
  
  /* data access */
  
! long db_read_art();
! long get_index_offset(), get_data_offset();
  
  extern data_header db_hdr;
  extern data_dynamic_data db_data;
*** decode.c.orig	Wed Sep  1 01:05:37 1993
--- decode.c	Sat Apr 15 04:57:50 1995
***************
*** 351,357 ****
  {
      int mode, onedone, len, lead_check = 0;
      char buf[LINELEN], part[2], *line;
!     off_t real_size, start_offset;
      long expect_size;
  
      onedone = 0;
--- 351,357 ----
  {
      int mode, onedone, len, lead_check = 0;
      char buf[LINELEN], part[2], *line;
!     long real_size, start_offset;
      long expect_size;
  
      onedone = 0;
*** digest.c.orig	Sun Aug 15 10:59:50 1993
--- digest.c	Sat Apr 15 04:57:50 1995
***************
*** 267,273 ****
  skip_digest_body(f)
  register FILE *f;
  {
!     off_t  backup_p[BACKUP_LINES];
      int	   line_type[BACKUP_LINES];
      register int backup_index, backup_count;
      int    more_header_lines, end_or_asterisks, blanks;
--- 267,273 ----
  skip_digest_body(f)
  register FILE *f;
  {
!     long   backup_p[BACKUP_LINES];
      int	   line_type[BACKUP_LINES];
      register int backup_index, backup_count;
      int    more_header_lines, end_or_asterisks, blanks;
*** expire.c.orig	Wed Sep  1 01:05:40 1993
--- expire.c	Sat Apr 15 04:57:51 1995
***************
*** 95,101 ****
  register group_header *gh;
  {
      FILE *old, *data, *ix;
!     off_t old_max_offset;
      register article_number *list;
      article_number old_last_article;
      long count;
--- 95,101 ----
  register group_header *gh;
  {
      FILE *old, *data, *ix;
!     long old_max_offset;
      register article_number *list;
      article_number old_last_article;
      long count;
***************
*** 149,157 ****
      old_last_article = gh->last_db_article;
      gh->last_db_article = 0;
  
!     gh->index_write_offset = (off_t)0;
      old_max_offset = gh->data_write_offset;
!     gh->data_write_offset = (off_t)0;
  
      gh->master_flag &= ~M_EXPIRE;
      gh->master_flag |= M_BLOCKED;
--- 149,157 ----
      old_last_article = gh->last_db_article;
      gh->last_db_article = 0;
  
!     gh->index_write_offset = (long)0;
      old_max_offset = gh->data_write_offset;
!     gh->data_write_offset = (long)0;
  
      gh->master_flag &= ~M_EXPIRE;
      gh->master_flag |= M_BLOCKED;
***************
*** 269,275 ****
  {
      FILE *old_x, *old_d;
      FILE *new;
!     off_t index_offset, data_offset, new_offset;
      long count, expire_count;
      char *err_message;
  
--- 269,275 ----
  {
      FILE *old_x, *old_d;
      FILE *new;
!     long index_offset, data_offset, new_offset;
      long count, expire_count;
      char *err_message;
  
***************
*** 336,342 ****
       *	calculate the number of entries to copy
       */
  
!     count = gh->index_write_offset / sizeof(off_t);
  
      /*
       *	data offset is the offset into the old data file for the
--- 336,342 ----
       *	calculate the number of entries to copy
       */
  
!     count = gh->index_write_offset / sizeof(long);
  
      /*
       *	data offset is the offset into the old data file for the
***************
*** 345,351 ****
       *	offset 'index_offset'.
       */
  
!     data_offset = (off_t)0;
  
      /*
       *	read 'count' entries from the old index file starting from
--- 345,351 ----
       *	offset 'index_offset'.
       */
  
!     data_offset = (long)0;
  
      /*
       *	read 'count' entries from the old index file starting from
***************
*** 359,365 ****
  	if (!db_read_offset(old_x, &new_offset))
  	    expire_error("INDEX: too short");
  
! 	if (data_offset == (off_t)0) data_offset = new_offset;
  
  	new_offset -= data_offset;
  	if (!db_write_offset(new, &new_offset))
--- 359,365 ----
  	if (!db_read_offset(old_x, &new_offset))
  	    expire_error("INDEX: too short");
  
! 	if (data_offset == (long)0) data_offset = new_offset;
  
  	new_offset -= data_offset;
  	if (!db_write_offset(new, &new_offset))
*** global.h.orig	Fri Feb 18 05:15:48 1994
--- global.h	Sat Apr 15 05:14:45 1995
***************
*** 8,14 ****
--- 8,16 ----
  #define _NN_GLOBAL_H 1
  
  #include <stdlib.h>
+ #ifdef USE_MALLOC_H
  #include <malloc.h>
+ #endif
  /*
   *	Marks for global/external variables
   */
***************
*** 88,100 ****
  
  /* define types of library functions */
  
  char 	*getenv(), *ctime();
  #ifndef MALLOC_FUNC_CHECK
  char 	*strchr(), *strrchr();
  #endif
! off_t 	lseek(), ftell(), tell();
  int	atoi();
  long	atol();
  
  
  /* define types of own functions */
--- 90,105 ----
  
  /* define types of library functions */
  
+ #ifndef __NetBSD__
  char 	*getenv(), *ctime();
  #ifndef MALLOC_FUNC_CHECK
  char 	*strchr(), *strrchr();
  #endif
! off_t   lseek(), tell();
! long    ftell();
  int	atoi();
  long	atol();
+ #endif
  
  
  /* define types of own functions */
***************
*** 387,398 ****
  void	db_read_group	__APROTO((group_header *gh));
  #endif
  void	db_write_group	__APROTO((group_header *gh));
! off_t	db_read_art	__APROTO((FILE *f));
  int	db_write_art	__APROTO((FILE *f));
! off_t	get_index_offset __APROTO((group_header *gh, article_number art_num));
! off_t	get_data_offset	 __APROTO((group_header *gh, article_number art_num));
! int	db_read_offset	__APROTO((FILE *f, off_t *offset));
! int	db_write_offset	__APROTO((FILE *f, off_t *offset));
  
  /* decode.c */
  
--- 392,403 ----
  void	db_read_group	__APROTO((group_header *gh));
  #endif
  void	db_write_group	__APROTO((group_header *gh));
! long    db_read_art     __APROTO((FILE *f));
  int	db_write_art	__APROTO((FILE *f));
! long    get_index_offset __APROTO((group_header *gh, article_number art_num));
! long    get_data_offset  __APROTO((group_header *gh, article_number art_num));
! int     db_read_offset  __APROTO((FILE *f, long *offset));
! int     db_write_offset __APROTO((FILE *f, long *offset));
  
  /* decode.c */
  
***************
*** 650,656 ****
  int	nntp_set_group		__APROTO((group_header *gh));
  int	nntp_get_active		__APROTO((void));
  FILE *	nntp_get_newsgroups	__APROTO((void));
! struct novgroup *nntp_get_overview	__APROTO((group_header *gh, int low, int high));
  FILE *	nntp_fopen_list		__APROTO((char *cmd));
  char *	nntp_fgets		__APROTO((char *buf, int size));
  article_number *nntp_get_article_list	__APROTO((group_header *gh));
--- 655,661 ----
  int	nntp_set_group		__APROTO((group_header *gh));
  int	nntp_get_active		__APROTO((void));
  FILE *	nntp_get_newsgroups	__APROTO((void));
! struct novgroup *nntp_get_overview      __APROTO((group_header *gh, article_number low, article_number high));
  FILE *	nntp_fopen_list		__APROTO((char *cmd));
  char *	nntp_fgets		__APROTO((char *buf, int size));
  article_number *nntp_get_article_list	__APROTO((group_header *gh));
*** kill.c.orig	Mon Sep 13 21:42:28 1993
--- kill.c	Sat Apr 15 04:57:52 1995
***************
*** 424,430 ****
  typedef struct {
      long		ckh_magic;
      time_t		ckh_db_check;
!     off_t		ckh_pattern_offset;
      long		ckh_pattern_size;
      long		ckh_entries;
      long		ckh_regexp_size;
--- 424,430 ----
  typedef struct {
      long		ckh_magic;
      time_t		ckh_db_check;
!     long                ckh_pattern_offset;
      long		ckh_pattern_size;
      long		ckh_entries;
      long		ckh_regexp_size;
***************
*** 579,585 ****
      comp_kill_header header;
      comp_kill_entry  entry;
      time_t now, age;
!     off_t cur_line_start;
      char line[512];
      register char *cp, *np;
      register int c;
--- 579,585 ----
      comp_kill_header header;
      comp_kill_entry  entry;
      time_t now, age;
!     long cur_line_start;
      char line[512];
      register char *cp, *np;
      register int c;
***************
*** 605,611 ****
  
      tprintf("\nCompiling kill file\n");
  
!     fseek(compf, (off_t)sizeof(header), 0);
  
      now = cur_time();
  
--- 605,611 ----
  
      tprintf("\nCompiling kill file\n");
  
!     fseek(compf, (long)sizeof(header), 0);
  
      now = cur_time();
  
***************
*** 844,850 ****
  
      if (header.ckh_pattern_size > 0) {
  	kill_patterns = newstr(header.ckh_pattern_size);
! 	fseek(killf, (off_t)(header.ckh_entries * sizeof(entry)), 1);
  	if (fread(kill_patterns, sizeof(char), (int)header.ckh_pattern_size, killf)
  	    !=  header.ckh_pattern_size) goto err;
      } else
--- 844,850 ----
  
      if (header.ckh_pattern_size > 0) {
  	kill_patterns = newstr(header.ckh_pattern_size);
! 	fseek(killf, (long)(header.ckh_entries * sizeof(entry)), 1);
  	if (fread(kill_patterns, sizeof(char), (int)header.ckh_pattern_size, killf)
  	    !=  header.ckh_pattern_size) goto err;
      } else
***************
*** 856,862 ****
  
      tb = group_regexp_table;
  
!     fseek(killf, (off_t)sizeof(header), 0);
      for (n = header.ckh_entries, kl = kill_tab; --n >= 0; kl++) {
  	if (fread((char *)&entry, sizeof(entry), 1, killf) != 1) goto err;
  	if (header.ckh_pattern_size <= entry.ck_pattern_index ||
--- 856,862 ----
  
      tb = group_regexp_table;
  
!     fseek(killf, (long)sizeof(header), 0);
      for (n = header.ckh_entries, kl = kill_tab; --n >= 0; kl++) {
  	if (fread((char *)&entry, sizeof(entry), 1, killf) != 1) goto err;
  	if (header.ckh_pattern_size <= entry.ck_pattern_index ||
*** Makefile.orig	Fri Feb 18 05:15:46 1994
--- Makefile	Sat Apr 15 04:57:52 1995
***************
*** 18,27 ****
  #
  # Use /lib/cpp or /usr/ccs/lib/cpp for CPP on Solaris or SVR4 machines.
  
! CC =		gcc
! #CPP =		$(CC) -E
! CPP =		/lib/cpp
! CFLAGS =	-O2 # -g # -I/usr/local/lib/malloc-debug -DMALLOC_FUNC_CHECK
  #-Wall -Wcomment \
  #-Wtraditional -Wshadow \
  #-Wpointer-arith -Wcast-qual -Wcast-align -Wconversion \
--- 18,27 ----
  #
  # Use /lib/cpp or /usr/ccs/lib/cpp for CPP on Solaris or SVR4 machines.
  
! #CC =            cc
! CPP =		$(CC) -E
! #CPP =		/lib/cpp
! #CFLAGS =        -O2 # -g # -I/usr/local/lib/malloc-debug -DMALLOC_FUNC_CHECK
  #-Wall -Wcomment \
  #-Wtraditional -Wshadow \
  #-Wpointer-arith -Wcast-qual -Wcast-align -Wconversion \
***************
*** 95,98 ****
  
  man/nn.1.D: man/nn.1
  	sh SPLITNN1
! 	
--- 95,100 ----
  
  man/nn.1.D: man/nn.1
  	sh SPLITNN1
! 
! install:
! 	./inst n
*** master.c.orig	Sat Oct  2 14:33:50 1993
--- master.c	Sat Apr 15 04:57:52 1995
***************
*** 193,200 ****
      gh->first_db_article = 0;
      gh->last_db_article = 0;
  
!     gh->data_write_offset = (off_t)0;
!     gh->index_write_offset = (off_t)0;
  
      if (init_group(gh)) {
  	(void)open_data_file(gh, 'd', -1);
--- 193,200 ----
      gh->first_db_article = 0;
      gh->last_db_article = 0;
  
!     gh->data_write_offset = (long)0;
!     gh->index_write_offset = (long)0;
  
      if (init_group(gh)) {
  	(void)open_data_file(gh, 'd', -1);
*** more.c.orig	Sat Oct  2 14:33:56 1993
--- more.c	Sat Apr 15 04:57:52 1995
***************
*** 352,360 ****
      register FILE *art;
      int more_cmd, eof, skip_spaces, has_space, window_lines;
      int form_feed, last_ff_line, ignore_nl = 0;
!     off_t firstl, lastl;
!     off_t lineposbuf[LINEMAX];
!     off_t *linepos = lineposbuf;
      int linemax = LINEMAX;
      char linebuf[200], skip_char;
      int skip_wrap;
--- 352,360 ----
      register FILE *art;
      int more_cmd, eof, skip_spaces, has_space, window_lines;
      int form_feed, last_ff_line, ignore_nl = 0;
!     long firstl, lastl;
!     long lineposbuf[LINEMAX];
!     long *linepos = lineposbuf;
      int linemax = LINEMAX;
      char linebuf[200], skip_char;
      int skip_wrap;
***************
*** 363,369 ****
      struct digest_header digest_save;
      int linenum, maxline, topline, print_lines, lno1;
      int scroll_lines, scroll_from;
!     off_t scroll_offset;
      int underline_line, fake_underline;
      int match_lines, match_redraw, match_topline = 0, match_botline;
      int goto_line, prev_goto, stop_line, extra_lines;
--- 363,369 ----
      struct digest_header digest_save;
      int linenum, maxline, topline, print_lines, lno1;
      int scroll_lines, scroll_from;
!     long scroll_offset;
      int underline_line, fake_underline;
      int match_lines, match_redraw, match_topline = 0, match_botline;
      int goto_line, prev_goto, stop_line, extra_lines;
***************
*** 653,663 ****
      if (linenum == linemax) {
  	linemax += 500;
  	if (linepos == lineposbuf) {
! 	    linepos = newobj(off_t, linemax);
  	    for (linenum = 0; linenum < LINEMAX; linenum++)
  		linepos[linenum] = lineposbuf[linenum];
  	} else
! 	    linepos = resizeobj(linepos, off_t, linemax);
      }
  
      if (goto_line == linenum) {
--- 653,663 ----
      if (linenum == linemax) {
  	linemax += 500;
  	if (linepos == lineposbuf) {
! 	    linepos = newobj(long, linemax);
  	    for (linenum = 0; linenum < LINEMAX; linenum++)
  		linepos[linenum] = lineposbuf[linenum];
  	} else
! 	    linepos = resizeobj(linepos, long, linemax);
      }
  
      if (goto_line == linenum) {
*** news.c.orig	Wed Sep  1 01:06:06 1993
--- news.c	Sat Apr 15 04:57:53 1995
***************
*** 23,29 ****
  {
      register char *bp, *cp, **fptr;
      int siz, all, date_only;
!     off_t pos;
  
      pos = ftell(f);
  
--- 23,29 ----
  {
      register char *bp, *cp, **fptr;
      int siz, all, date_only;
!     long pos;
  
      pos = ftell(f);
  
***************
*** 239,245 ****
      struct stat statb;
  #ifdef NNTP
      int lazy;
!     off_t fpos;
      FILE *nntp_get_article();
  #endif /* NNTP */
  
--- 239,245 ----
      struct stat statb;
  #ifdef NNTP
      int lazy;
!     long fpos;
      FILE *nntp_get_article();
  #endif /* NNTP */
  
***************
*** 266,274 ****
  	/* necessary because empty files wreak havoc */
  	if (fstat(fileno(f), &statb) < 0 ||
  #ifdef NOV
! 	    (art->lpos = statb.st_size, statb.st_size <= (off_t)0)) {
  #else
! 	    statb.st_size < art->lpos || statb.st_size <= (off_t)0) {
  #endif /* NOV */
  	    fclose(f);
  	    return who_am_i == I_AM_MASTER ? (FILE *)1 : NULL;
--- 266,274 ----
  	/* necessary because empty files wreak havoc */
  	if (fstat(fileno(f), &statb) < 0 ||
  #ifdef NOV
! 	    (art->lpos = (long)statb.st_size, statb.st_size <= (off_t)0)) {
  #else
! 	    (long)statb.st_size < art->lpos || statb.st_size <= (off_t)0) {
  #endif /* NOV */
  	    fclose(f);
  	    return who_am_i == I_AM_MASTER ? (FILE *)1 : NULL;
***************
*** 351,362 ****
  	}
  
  	if (modes & FILL_OFFSETS) {
! 	    fseek(f, (off_t)0, 2);
  	    news.ng_lpos = ftell(f);
  	}
  #ifdef NNTP
  	else if (use_nntp && (art->flag & (A_DIGEST | A_FOLDER)) == 0) {
! 	    fseek(f, (off_t)0, 2);
  	    art->lpos = ftell(f);
  	}
  #endif
--- 351,362 ----
  	}
  
  	if (modes & FILL_OFFSETS) {
! 	    fseek(f, (long)0, 2);
  	    news.ng_lpos = ftell(f);
  	}
  #ifdef NNTP
  	else if (use_nntp && (art->flag & (A_DIGEST | A_FOLDER)) == 0) {
! 	    fseek(f, (long)0, 2);
  	    art->lpos = ftell(f);
  	}
  #endif
***************
*** 378,384 ****
      }
  #ifdef NNTP
      else if (use_nntp && (art->flag & (A_DIGEST | A_FOLDER)) == 0) {
! 	fseek(f, (off_t)0, 2);
  	art->lpos = ftell(f);
      }
  #endif
--- 378,384 ----
      }
  #ifdef NNTP
      else if (use_nntp && (art->flag & (A_DIGEST | A_FOLDER)) == 0) {
! 	fseek(f, (long)0, 2);
  	art->lpos = ftell(f);
      }
  #endif
*** news.h.orig	Wed Sep  1 01:06:07 1993
--- news.h	Sat Apr 15 04:57:53 1995
***************
*** 13,20 ****
  #	  define N_DIGEST 1	/*   article is part of a digest*/
  #	  define N_MODERATED 2	/*   group is moderated		*/
  
! 	off_t	ng_fpos;	/* position of article text	*/
! 	off_t	ng_lpos;	/* last text offset		*/
  				/* header lines:		*/
  	char	*ng_from;	/*   from			*/
  	char	*ng_name;	/*   senders name		*/
--- 13,20 ----
  #	  define N_DIGEST 1	/*   article is part of a digest*/
  #	  define N_MODERATED 2	/*   group is moderated		*/
  
! 	long    ng_fpos;        /* position of article text     */
! 	long    ng_lpos;        /* last text offset             */
  				/* header lines:		*/
  	char	*ng_from;	/*   from			*/
  	char	*ng_name;	/*   senders name		*/
***************
*** 51,59 ****
   */
  
  struct digest_header {
! 	off_t	dg_hpos;	/* position of article header	*/
! 	off_t	dg_fpos;	/* position of article text	*/
! 	off_t	dg_lpos;	/* last text position		*/
  				/* header lines:		*/
  	char	*dg_date;	/*   date			*/
  	char	*dg_from;	/*   from			*/
--- 51,59 ----
   */
  
  struct digest_header {
! 	long    dg_hpos;        /* position of article header   */
! 	long    dg_fpos;        /* position of article text     */
! 	long    dg_lpos;        /* last text position           */
  				/* header lines:		*/
  	char	*dg_date;	/*   date			*/
  	char	*dg_from;	/*   from			*/
*** newsrc.c.orig	Thu Sep 23 06:11:10 1993
--- newsrc.c	Sat Apr 15 04:57:53 1995
***************
*** 379,385 ****
  
      rc = open_file(newsrc_file, OPEN_READ);
      if (rc != NULL) {
! 	fseek(rc, (off_t)0, 2);
  	if (ftell(rc))
  	    rewind(rc);
  	else {
--- 379,385 ----
  
      rc = open_file(newsrc_file, OPEN_READ);
      if (rc != NULL) {
! 	fseek(rc, (long)0, 2);
  	if (ftell(rc))
  	    rewind(rc);
  	else {
*** nntp.c.orig	Thu Nov 25 12:39:37 1993
--- nntp.c	Sat Apr 15 04:57:54 1995
***************
*** 85,91 ****
--- 85,93 ----
  import int silent, no_update;
  
  import int sys_nerr;
+ #ifndef __NetBSD__
  import char *sys_errlist[];
+ #endif
  extern void nn_exitmsg();
  extern void sys_error();
  extern int sys_warning();
***************
*** 1098,1104 ****
  
       case OK_BODY:
  	tmp = open_file(cptr->file_name, OPEN_APPEND|MUST_EXIST);
! 	fseek(tmp, (off_t)0, 2);
  	if (copy_text(tmp) < 0)
  	    return NULL;
  	if (fclose(tmp) == EOF) goto err;
--- 1100,1106 ----
  
       case OK_BODY:
  	tmp = open_file(cptr->file_name, OPEN_APPEND|MUST_EXIST);
! 	fseek(tmp, (long)0, 2);
  	if (copy_text(tmp) < 0)
  	    return NULL;
  	if (fclose(tmp) == EOF) goto err;
*** save.c.orig	Mon Sep 13 21:42:52 1993
--- save.c	Sat Apr 15 04:57:54 1995
***************
*** 514,520 ****
  		return 0;
  	    }
  	    current_folder_type = -1;
! 	    if (ftell(save_file) != (off_t)0) {
  		if (mode != NO_HEADER) set_folder_type(save_name);
  		save_mode &= ~FILE_IS_NEW;
  	    }
--- 514,520 ----
  		return 0;
  	    }
  	    current_folder_type = -1;
! 	    if (ftell(save_file) != (long)0) {
  		if (mode != NO_HEADER) set_folder_type(save_name);
  		save_mode &= ~FILE_IS_NEW;
  	    }
***************
*** 531,537 ****
  	mailbox_format(save_file, 1);
  
      if (mode == FULL_HEADER) {
! 	off_t cnt = ah->fpos - ah->hpos;
  	while (--cnt >= 0) {
  	    if ((c = getc(art)) == EOF) break;
  	    putc(c, save_file);
--- 531,537 ----
  	mailbox_format(save_file, 1);
  
      if (mode == FULL_HEADER) {
! 	long cnt = ah->fpos - ah->hpos;
  	while (--cnt >= 0) {
  	    if ((c = getc(art)) == EOF) break;
  	    putc(c, save_file);
***************
*** 647,653 ****
  char *dir, *file;
  {
      register int c;
!     off_t endpos;
      FILE *h;
  
      if (dir != (char *)NULL && file[0] != '/')
--- 647,653 ----
  char *dir, *file;
  {
      register int c;
!     long endpos;
      FILE *h;
  
      if (dir != (char *)NULL && file[0] != '/')
***************
*** 656,662 ****
  	msg("Cannot open %s", file);
  	return;
      }
!     fseek(h, (off_t)0, 2);
      if (ftell(h) > 0)
  	set_folder_type(file);
      else
--- 656,662 ----
  	msg("Cannot open %s", file);
  	return;
      }
!     fseek(h, (long)0, 2);
      if (ftell(h) > 0)
  	set_folder_type(file);
      else
*** sort.c.orig	Wed Sep  1 01:06:25 1993
--- sort.c	Sat Apr 15 04:57:54 1995
***************
*** 43,48 ****
--- 43,71 ----
   *	before MATCH_?? (t, a, b) is used.
   */
  
+ #ifdef HAVE_WORKING_COLLATE
+ 
+ #ifdef HAVE_8BIT_CTYPE
+ #define MATCH_DROP(table, c) !isprint(c)
+ #else
+ #define MATCH_DROP(table, c) ( c & 0200 || !isprint(c) )
+ #endif
+ #define MATCH_EQ(table, a, b) ( a == b || table(a, b) == 0 )
+ #define MATCH_LS_EQ(table, a, b) ( a == b || table(a, b) <= 0 )
+ #define MATCH_LS(table, a, b) ( table(a, b) < 0 )
+ #define MATCH_CMP(table, a, b) table(a, b)
+ 
+ static int match_subject(a, b)
+ char a, b;
+ {
+ 	static char aa[2], bb[2];
+ 
+ 	aa[0] = a; bb[0] = b;
+ 	return strcoll(aa, bb);
+ }
+ 
+ #else
+ 
  #define	MATCH_DROP(table, c) ( c & 0200 || table[c] == 0 )
  #define MATCH_EQ(table, a, b) ( a == b || table[a] == table[b] )
  #define MATCH_LS_EQ(table, a, b) ( a <= b || table[a] <= table[b] )
***************
*** 77,82 ****
--- 100,106 ----
      26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 00, 00
  };
  
+ #endif /* HAVE_WORKING_COLLATE */
  
  static int
  order_subj_date(ah1, ah2)
*** term.c.old	Sat Oct  2 14:34:09 1993
--- term.c	Sat Apr 15 06:45:11 1995
***************
*** 26,31 ****
--- 26,35 ----
  #include <setjmp.h>
  #endif
  
+ #ifdef HAVE_TERMIOS
+ #include <termios.h>
+ #endif
+ 
  #ifdef USE_TERMINFO
  # ifdef HPUX80
  # include <termio.h>
***************
*** 46,53 ****
--- 50,59 ----
  #  include <termio.h>
  # endif	/* USE_TERMCAP */
  #else
+ #ifndef HAVE_TERMIOS
  # include <sgtty.h>
  #endif
+ #endif
  
  /* SYSV curses.h clash */
  #undef raw
***************
*** 206,212 ****
  extern char fake_keyb_siglist[];
  #endif	/* FAKE_INTERRUPT */
  
! #ifdef HAVE_TERMIO
  
  /* This used to be 50, but there are some rather complex bugs in the SYSV */
  /* TERMIO driver... */
--- 212,218 ----
  extern char fake_keyb_siglist[];
  #endif	/* FAKE_INTERRUPT */
  
! #if defined(HAVE_TERMIO) || defined(HAVE_TERMIOS)
  
  /* This used to be 50, but there are some rather complex bugs in the SYSV */
  /* TERMIO driver... */
***************
*** 214,225 ****
--- 220,239 ----
  
  #undef CBREAK
  
+ #ifdef HAVE_TERMIOS
+ static struct termios norm_tty, raw_tty;
+ #else
  static struct termio norm_tty, raw_tty;
+ #endif
  
  #define	IntrC	((key_type) norm_tty.c_cc[VINTR])
  #define	EraseC	((key_type) norm_tty.c_cc[VERASE])
  #define KillC	((key_type) norm_tty.c_cc[VKILL])
+ #ifdef HAVE_TERMIOS
+ #define SuspC   ((key_type) norm_tty.c_cc[VSUSP])
+ #else
  #define SuspC	((key_type) CONTROL_('Z'))	/* norm_tty.c_cc[SWTCH] */
+ #endif
  
  #else	/* V7/BSD TTY DRIVER */
  
***************
*** 390,395 ****
--- 404,415 ----
  #endif	/* FAKE_INTERRUPT */
  
  static unsigned sp_table[] = {
+ #ifdef B115200
+     B115200, 11520,
+ #endif
+ #ifdef B57600
+     B57600, 5760,
+ #endif
      B9600, 960,
  #ifdef B19200
      B19200, 1920,
***************
*** 473,479 ****
--- 493,503 ----
  #ifdef HAVE_TERMIO
      ioctl(0, TCGETA, &norm_tty);
  #else
+ #ifdef HAVE_TERMIOS
+     tcgetattr(0, &norm_tty);
+ #else
      ioctl(0, TIOCGETP, &norm_tty);
+ #endif
  #endif	/* HAVE_TERMIO */
  
  #ifdef USE_TERMINFO
***************
*** 581,586 ****
--- 605,621 ----
      raw_tty.c_cc[VTIME] = ((int)(raw_tty.c_cflag & CBAUD) > B1200) ? 1 : 2;
      set_term_speed((unsigned long)(raw_tty.c_cflag & CBAUD));
  #else
+ #ifdef HAVE_TERMIOS
+     cfmakeraw(&raw_tty);
+     /* read a maximum of 10 characters in one burst; timeout in 1-200 ms */
+     raw_tty.c_cc[VMIN] = KEY_BURST;
+     raw_tty.c_cc[VTIME] = (cfgetispeed(&raw_tty) > B1200) ? 1 : 2;
+     set_term_speed((unsigned long)cfgetospeed(&raw_tty));
+ #ifdef SV_INTERRUPT
+     siginterrupt(SIGTSTP, 1);
+     siginterrupt(SIGALRM, 1);
+ #endif	/* SV_INTERRUPT */
+ #else
      ioctl(0, TIOCGETC, &norm_chars);
  
  #ifdef TIOCGLTC
***************
*** 603,608 ****
--- 638,644 ----
  #ifdef SV_INTERRUPT
      siginterrupt(SIGALRM, 1);		/* make read from tty interruptable */
  #endif	/* SV_INTERRUPT */
+ #endif
  #endif	/* HAVE_TERMIO */
  
      erase_key = EraseC;
***************
*** 1124,1131 ****
--- 1160,1172 ----
  #define RAW_MODE_ON    ioctl(0, TCSETAW, &raw_tty)
  #define RAW_MODE_OFF   ioctl(0, TCSETAW, &norm_tty)
  #else
+ #ifdef HAVE_TERMIOS
+ #define RAW_MODE_ON    tcsetattr(0, TCSADRAIN, &raw_tty)
+ #define RAW_MODE_OFF   tcsetattr(0, TCSADRAIN, &norm_tty)
+ #else
  #define RAW_MODE_ON    ioctl(0, TIOCSETP, &raw_tty)
  #define RAW_MODE_OFF   ioctl(0, TIOCSETP, &norm_tty)
+ #endif
  #endif	/* HAVE_TERMIO */
  
  void
***************
*** 1344,1355 ****
--- 1385,1400 ----
  #ifdef HAVE_TERMIO
      ioctl(0, TCFLSH, 0);
  #else
+ #ifdef HAVE_TERMIOS
+     tcflush(0, TCIFLUSH);
+ #else
  #ifdef FREAD
      arg = FREAD;
      ioctl(0, TIOCFLUSH, &arg);
  #else
      ioctl(0, TIOCFLUSH, 0);
  #endif	/* FREAD */
+ #endif
  #endif	/* HAVE_TERMIO */
      rd_count = 0;
  }
