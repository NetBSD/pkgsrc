$NetBSD: patch-ai,v 1.3 2001/12/03 15:37:15 skrll Exp $

--- klaptopdaemon/portable.cpp.orig	Sun Feb 18 15:31:14 2001
+++ klaptopdaemon/portable.cpp
@@ -658,6 +658,238 @@
 {
 	return(1);
 }
+
+#elif  __NetBSD_APM__
+
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <machine/apmvar.h>
+#include <iostream.h>
+
+//
+// klaptopdeamon interface to NetBSD 1.5 apm.
+// Scott Presnell, srp@zgi.com, srp@tworoads.net
+// Fri Jun 29 17:21:25 PDT 2001
+// Tested on Dell I4K running NetBSD 1.5R
+//
+#define APMDEV "/dev/apm"
+
+//
+//	Check for apm in kernel by talking to /dev/apm
+//	(opening read only is allowed by any process).
+//	returns 1 if we support power management
+//
+int
+laptop_portable::has_power_management()
+{
+	int ret, fd = ::open(APMDEV, O_RDONLY);
+
+	if (fd == -1) {
+	  return 0;
+	}
+
+	struct apm_power_info info;
+	ret=ioctl(fd, APM_IOC_GETPOWER, &info);
+	::close(fd);
+
+	if (ret == -1) {
+	  return 0;
+	}
+
+	return 1;
+}
+
+//
+//	returns 1 if the BIOS returns the time left in the battery rather than a % of full
+//
+int laptop_portable::has_battery_time()
+{
+	int ret, fd = ::open(APMDEV, O_RDONLY);
+
+	if (fd == -1)
+	  return 0;
+
+	struct apm_power_info info;
+	ret=ioctl(fd, APM_IOC_GETPOWER, &info);
+	::close(fd);
+
+	if (ret == -1)
+	  return 0;
+
+	return (info.minutes_left != 0xffff);
+}
+
+//
+//	returns 1 if we can perform a change-to-suspend-mode operation for the user
+//	(ust check to see if we have the binary)
+//	(has_power_management() has already returned 1)
+//
+int laptop_portable::has_suspend()
+{
+
+	struct stat s;
+        if (stat("/usr/sbin/apm", &s))
+		return(0);
+	return(1);
+}
+
+//
+//	returns 1 if we can perform a change-to-standby-mode operation for the user
+//	(just check to see if we have the binary)
+//	(has_power_management() has already returned 1)
+//
+int laptop_portable::has_standby()
+{
+
+	struct stat s;
+        if (stat("/usr/sbin/apm", &s))
+		return(0);
+	return(1);
+}
+
+//
+//	returns 1 if we can perform a change-to-hibernate-mode for a user
+//      (has_power_management() has already returned 1)  [hibernate is the save-to-disk mode
+//	not supported by linux - different laptops have their own - the first here is for 
+//	a ThinkPad]
+//	No support in NetBSD at this time.
+//
+int laptop_portable::has_hibernation()
+{
+	return(0);
+}
+
+//
+//	explain to the user what they need to do if has_power_management() returned 0
+//	to get any software they lack
+//
+QLabel *laptop_portable::no_power_management_explanation(QWidget *parent)
+{
+  int fd;
+  QLabel *explain;
+
+  fd = ::open(APMDEV, O_RDONLY);
+  if (fd == -1) {
+    switch (errno) {
+    case ENOENT:
+      explain = new QLabel("There is no /dev/apm file on this system.  Pleae review the NetBSD documentation on how to create a device node for the apm device driver (man 4 apm)", parent);
+      break;
+    case EACCES:
+      explain = new QLabel("Your system has the proper device node for apm support, however you can't access it. If you have apm in the kernel this should not happen", parent);
+      break;
+    case ENXIO:
+      explain = new QLabel("Your kernel lacks support for Advanced Power Managment.", parent);
+      break;
+      break;
+    default:
+      explain = new QLabel("There was some generic error while opening /dev/apm.", parent);
+      break;
+    }
+  } else {
+    close(fd);
+    explain = new QLabel("APM has most likely been disabled.  Oops", parent);
+  }
+  
+  explain->setMinimumSize(explain->sizeHint());       
+  return(explain);
+}
+
+//
+//	explain to the user what they need to do to get suspend/resume to work from user mode
+//
+QLabel *laptop_portable::how_to_do_suspend_resume(QWidget *parent)
+{
+ 	QLabel* note = new QLabel(i18n(" "), parent);
+        note->setMinimumSize(note->sizeHint()); 
+	return(note);
+}
+
+//
+//	pcmcia support - this will be replaced by better - pcmcia support being worked on by
+//	others
+//
+QLabel *laptop_portable::pcmcia_info(int x, QWidget *parent)
+{
+      	if (x == 0)
+		return(new QLabel(i18n("No PCMCIA controller detected"), parent));
+      	return(new QLabel(i18n(""), parent));
+}
+
+//
+//	puts us into standby mode
+//	Use apm rather than ioctls in case they are running apmd
+//	(as they should be).
+//
+void laptop_portable::invoke_standby()
+{
+	::system("/usr/sbin/apm -S");    
+}
+
+//
+//	puts us into suspend mode
+//	Use apm rather than ioctls in case they are running apmd
+//	(as they should be).
+//
+void laptop_portable::invoke_suspend()
+{
+
+	::system("/usr/sbin/apm -z");    
+}
+
+//
+//	puts us into hibernate mode
+//	No hibernate mode for NetBSD.
+//
+void laptop_portable::invoke_hibernation()
+{
+	return;
+}
+
+
+//
+//	return current battery state
+//
+struct power_result laptop_portable::poll_battery_state()
+{
+	struct power_result p;
+       	int ret;
+
+       	int fd = ::open(APMDEV, O_RDONLY);
+
+       	if (fd == -1)
+         	goto bad;
+
+       	struct apm_power_info info;
+       	ret=ioctl(fd, APM_IOC_GETPOWER, &info);
+       	::close(fd);
+	
+       	if (ret == -1)
+         	goto bad;
+
+       	p.powered = (info.ac_state == APM_AC_ON);
+       	p.percentage = (info.battery_life==255 ? 100 : info.battery_life);
+       	p.time = (info.minutes_left != 0xffff ? info.minutes_left : -1);
+       	return(p);
+
+bad:
+       	p.powered = 1; 
+	p.percentage = 100;
+	p.time = 0;
+	return(p);
+}
+
+//
+//
+//	returns true if any mouse or kdb activity has been detected
+//	
+int laptop_portable::poll_activity()
+{
+	return(1);
+}
 #else
 
 // INSERT HERE
