$NetBSD: patch-db,v 1.1.2.1 2006/12/09 09:13:15 salo Exp $

Move some inlined functions to a place before they are used,
otherwise GCC barfs when -fno-unit-a-time is active.

--- src/libffmpeg/libavcodec/mpeg12.c.orig	2006-08-02 08:02:39.000000000 +0100
+++ src/libffmpeg/libavcodec/mpeg12.c
@@ -1074,515 +1074,370 @@ static inline int get_qscale(MpegEncCont
 #define MT_16X8  2
 #define MT_DMV   3
 
-static int mpeg_decode_mb(MpegEncContext *s,
-                          DCTELEM block[12][64])
+static inline int decode_dc(GetBitContext *gb, int component)
 {
-    int i, j, k, cbp, val, mb_type, motion_type;
-    const int mb_block_count = 4 + (1<< s->chroma_format);
+    int code, diff;
 
-    dprintf("decode_mb: x=%d y=%d\n", s->mb_x, s->mb_y);
+    if (component == 0) {
+        code = get_vlc2(gb, dc_lum_vlc.table, DC_VLC_BITS, 2);
+    } else {
+        code = get_vlc2(gb, dc_chroma_vlc.table, DC_VLC_BITS, 2);
+    }
+    if (code < 0){
+        av_log(NULL, AV_LOG_ERROR, "invalid dc code at\n");
+        return 0xffff;
+    }
+    if (code == 0) {
+        diff = 0;
+    } else {
+        diff = get_xbits(gb, code);
+    }
+    return diff;
+}
 
-    assert(s->mb_skipped==0);
+static inline int mpeg2_fast_decode_block_intra(MpegEncContext *s,
+                               DCTELEM *block,
+                               int n)
+{
+    int level, dc, diff, j, run;
+    int component;
+    RLTable *rl;
+    uint8_t * scantable= s->intra_scantable.permutated;
+    const uint16_t *quant_matrix;
+    const int qscale= s->qscale;
 
-    if (s->mb_skip_run-- != 0) {
-        if(s->pict_type == I_TYPE){
-            av_log(s->avctx, AV_LOG_ERROR, "skipped MB in I frame at %d %d\n", s->mb_x, s->mb_y);
-            return -1;
-        }
+    /* DC coef */
+    if (n < 4){
+        quant_matrix = s->intra_matrix;
+        component = 0;
+    }else{
+        quant_matrix = s->chroma_intra_matrix;
+        component = (n&1) + 1;
+    }
+    diff = decode_dc(&s->gb, component);
+    if (diff >= 0xffff)
+        return -1;
+    dc = s->last_dc[component];
+    dc += diff;
+    s->last_dc[component] = dc;
+    block[0] = dc << (3 - s->intra_dc_precision);
+    if (s->intra_vlc_format)
+        rl = &rl_mpeg2;
+    else
+        rl = &rl_mpeg1;
 
-        /* skip mb */
-        s->mb_intra = 0;
-        for(i=0;i<12;i++)
-            s->block_last_index[i] = -1;
-        if(s->picture_structure == PICT_FRAME)
-            s->mv_type = MV_TYPE_16X16;
-        else
-            s->mv_type = MV_TYPE_FIELD;
-        if (s->pict_type == P_TYPE) {
-            /* if P type, zero motion vector is implied */
-            s->mv_dir = MV_DIR_FORWARD;
-            s->mv[0][0][0] = s->mv[0][0][1] = 0;
-            s->last_mv[0][0][0] = s->last_mv[0][0][1] = 0;
-            s->last_mv[0][1][0] = s->last_mv[0][1][1] = 0;
-            s->field_select[0][0]= s->picture_structure - 1;
-            s->mb_skipped = 1;
-            s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= MB_TYPE_SKIP | MB_TYPE_L0 | MB_TYPE_16x16;
-        } else {
-            int mb_type;
+    {
+        OPEN_READER(re, &s->gb);
+        /* now quantify & encode AC coefs */
+        for(;;) {
+            UPDATE_CACHE(re, &s->gb);
+            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
 
-            if(s->mb_x)
-                mb_type= s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride - 1];
-            else
-                mb_type= s->current_picture.mb_type[ s->mb_width + (s->mb_y-1)*s->mb_stride - 1]; // FIXME not sure if this is allowed in mpeg at all,
-            if(IS_INTRA(mb_type))
-                return -1;
+            if(level == 127){
+                break;
+            } else if(level != 0) {
+                scantable += run;
+                j = *scantable;
+                level= (level*qscale*quant_matrix[j])>>4;
+                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
+                LAST_SKIP_BITS(re, &s->gb, 1);
+            } else {
+                /* escape */
+                run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
+                UPDATE_CACHE(re, &s->gb);
+                level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
+                scantable += run;
+                j = *scantable;
+                if(level<0){
+                    level= (-level*qscale*quant_matrix[j])>>4;
+                    level= -level;
+                }else{
+                    level= (level*qscale*quant_matrix[j])>>4;
+                }
+            }
 
-            /* if B type, reuse previous vectors and directions */
-            s->mv[0][0][0] = s->last_mv[0][0][0];
-            s->mv[0][0][1] = s->last_mv[0][0][1];
-            s->mv[1][0][0] = s->last_mv[1][0][0];
-            s->mv[1][0][1] = s->last_mv[1][0][1];
+            block[j] = level;
+        }
+        CLOSE_READER(re, &s->gb);
+    }
 
-            s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]=
-                mb_type | MB_TYPE_SKIP;
-//            assert(s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride - 1]&(MB_TYPE_16x16|MB_TYPE_16x8));
+    s->block_last_index[n] = scantable - s->intra_scantable.permutated;
+    return 0;
+}
 
-            if((s->mv[0][0][0]|s->mv[0][0][1]|s->mv[1][0][0]|s->mv[1][0][1])==0)
-                s->mb_skipped = 1;
-        }
+static inline int mpeg2_decode_block_intra(MpegEncContext *s,
+                               DCTELEM *block,
+                               int n)
+{
+    int level, dc, diff, i, j, run;
+    int component;
+    RLTable *rl;
+    uint8_t * const scantable= s->intra_scantable.permutated;
+    const uint16_t *quant_matrix;
+    const int qscale= s->qscale;
+    int mismatch;
 
-        return 0;
+    /* DC coef */
+    if (n < 4){
+        quant_matrix = s->intra_matrix;
+        component = 0;
+    }else{
+        quant_matrix = s->chroma_intra_matrix;
+        component = (n&1) + 1;
     }
+    diff = decode_dc(&s->gb, component);
+    if (diff >= 0xffff)
+        return -1;
+    dc = s->last_dc[component];
+    dc += diff;
+    s->last_dc[component] = dc;
+    block[0] = dc << (3 - s->intra_dc_precision);
+    dprintf("dc=%d\n", block[0]);
+    mismatch = block[0] ^ 1;
+    i = 0;
+    if (s->intra_vlc_format)
+        rl = &rl_mpeg2;
+    else
+        rl = &rl_mpeg1;
 
-    switch(s->pict_type) {
-    default:
-    case I_TYPE:
-        if (get_bits1(&s->gb) == 0) {
-            if (get_bits1(&s->gb) == 0){
-                av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in I Frame at %d %d\n", s->mb_x, s->mb_y);
+    {
+        OPEN_READER(re, &s->gb);
+        /* now quantify & encode AC coefs */
+        for(;;) {
+            UPDATE_CACHE(re, &s->gb);
+            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
+
+            if(level == 127){
+                break;
+            } else if(level != 0) {
+                i += run;
+                j = scantable[i];
+                level= (level*qscale*quant_matrix[j])>>4;
+                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
+                LAST_SKIP_BITS(re, &s->gb, 1);
+            } else {
+                /* escape */
+                run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
+                UPDATE_CACHE(re, &s->gb);
+                level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
+                i += run;
+                j = scantable[i];
+                if(level<0){
+                    level= (-level*qscale*quant_matrix[j])>>4;
+                    level= -level;
+                }else{
+                    level= (level*qscale*quant_matrix[j])>>4;
+                }
+            }
+            if (i > 63){
+                av_log(s->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);
                 return -1;
             }
-            mb_type = MB_TYPE_QUANT | MB_TYPE_INTRA;
-        } else {
-            mb_type = MB_TYPE_INTRA;
-        }
-        break;
-    case P_TYPE:
-        mb_type = get_vlc2(&s->gb, mb_ptype_vlc.table, MB_PTYPE_VLC_BITS, 1);
-        if (mb_type < 0){
-            av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in P Frame at %d %d\n", s->mb_x, s->mb_y);
-            return -1;
-        }
-        mb_type = ptype2mb_type[ mb_type ];
-        break;
-    case B_TYPE:
-        mb_type = get_vlc2(&s->gb, mb_btype_vlc.table, MB_BTYPE_VLC_BITS, 1);
-        if (mb_type < 0){
-            av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in B Frame at %d %d\n", s->mb_x, s->mb_y);
-            return -1;
-        }
-        mb_type = btype2mb_type[ mb_type ];
-        break;
-    }
-    dprintf("mb_type=%x\n", mb_type);
-//    motion_type = 0; /* avoid warning */
-    if (IS_INTRA(mb_type)) {
-        s->dsp.clear_blocks(s->block[0]);
 
-        if(!s->chroma_y_shift){
-            s->dsp.clear_blocks(s->block[6]);
+            mismatch^= level;
+            block[j] = level;
         }
+        CLOSE_READER(re, &s->gb);
+    }
+    block[63]^= mismatch&1;
 
-        /* compute dct type */
-        if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?
-            !s->frame_pred_frame_dct) {
-            s->interlaced_dct = get_bits1(&s->gb);
-        }
+    s->block_last_index[n] = i;
+    return 0;
+}
 
-        if (IS_QUANT(mb_type))
-            s->qscale = get_qscale(s);
+static inline int mpeg1_decode_block_intra(MpegEncContext *s,
+                               DCTELEM *block,
+                               int n)
+{
+    int level, dc, diff, i, j, run;
+    int component;
+    RLTable *rl = &rl_mpeg1;
+    uint8_t * const scantable= s->intra_scantable.permutated;
+    const uint16_t *quant_matrix= s->intra_matrix;
+    const int qscale= s->qscale;
 
-        if (s->concealment_motion_vectors) {
-            /* just parse them */
-            if (s->picture_structure != PICT_FRAME)
-                skip_bits1(&s->gb); /* field select */
-
-            s->mv[0][0][0]= s->last_mv[0][0][0]= s->last_mv[0][1][0] =
-                mpeg_decode_motion(s, s->mpeg_f_code[0][0], s->last_mv[0][0][0]);
-            s->mv[0][0][1]= s->last_mv[0][0][1]= s->last_mv[0][1][1] =
-                mpeg_decode_motion(s, s->mpeg_f_code[0][1], s->last_mv[0][0][1]);
-
-            skip_bits1(&s->gb); /* marker */
-        }else
-            memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */
-        s->mb_intra = 1;
-#ifdef HAVE_XVMC
-        //one 1 we memcpy blocks in xvmcvideo
-        if(s->avctx->xvmc_acceleration > 1){
-            XVMC_pack_pblocks(s,-1);//inter are always full blocks
-            if(s->swap_uv){
-                exchange_uv(s);
-            }
-        }
-#endif
+    /* DC coef */
+    component = (n <= 3 ? 0 : n - 4 + 1);
+    diff = decode_dc(&s->gb, component);
+    if (diff >= 0xffff)
+        return -1;
+    dc = s->last_dc[component];
+    dc += diff;
+    s->last_dc[component] = dc;
+    block[0] = dc<<3;
+    dprintf("dc=%d diff=%d\n", dc, diff);
+    i = 0;
+    {
+        OPEN_READER(re, &s->gb);
+        /* now quantify & encode AC coefs */
+        for(;;) {
+            UPDATE_CACHE(re, &s->gb);
+            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
 
-        if (s->codec_id == CODEC_ID_MPEG2VIDEO) {
-            if(s->flags2 & CODEC_FLAG2_FAST){
-                for(i=0;i<6;i++) {
-                    mpeg2_fast_decode_block_intra(s, s->pblocks[i], i);
-                }
-            }else{
-                for(i=0;i<mb_block_count;i++) {
-                    if (mpeg2_decode_block_intra(s, s->pblocks[i], i) < 0)
-                        return -1;
+            if(level == 127){
+                break;
+            } else if(level != 0) {
+                i += run;
+                j = scantable[i];
+                level= (level*qscale*quant_matrix[j])>>4;
+                level= (level-1)|1;
+                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
+                LAST_SKIP_BITS(re, &s->gb, 1);
+            } else {
+                /* escape */
+                run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
+                UPDATE_CACHE(re, &s->gb);
+                level = SHOW_SBITS(re, &s->gb, 8); SKIP_BITS(re, &s->gb, 8);
+                if (level == -128) {
+                    level = SHOW_UBITS(re, &s->gb, 8) - 256; LAST_SKIP_BITS(re, &s->gb, 8);
+                } else if (level == 0) {
+                    level = SHOW_UBITS(re, &s->gb, 8)      ; LAST_SKIP_BITS(re, &s->gb, 8);
                 }
-            }
-        } else {
-            for(i=0;i<6;i++) {
-                if (mpeg1_decode_block_intra(s, s->pblocks[i], i) < 0)
-                    return -1;
-            }
-        }
-    } else {
-        if (mb_type & MB_TYPE_ZERO_MV){
-            assert(mb_type & MB_TYPE_CBP);
-
-            /* compute dct type */
-            if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?
-                !s->frame_pred_frame_dct) {
-                s->interlaced_dct = get_bits1(&s->gb);
-            }
-
-            if (IS_QUANT(mb_type))
-                s->qscale = get_qscale(s);
-
-            s->mv_dir = MV_DIR_FORWARD;
-            if(s->picture_structure == PICT_FRAME)
-                s->mv_type = MV_TYPE_16X16;
-            else{
-                s->mv_type = MV_TYPE_FIELD;
-                mb_type |= MB_TYPE_INTERLACED;
-                s->field_select[0][0]= s->picture_structure - 1;
-            }
-            s->last_mv[0][0][0] = 0;
-            s->last_mv[0][0][1] = 0;
-            s->last_mv[0][1][0] = 0;
-            s->last_mv[0][1][1] = 0;
-            s->mv[0][0][0] = 0;
-            s->mv[0][0][1] = 0;
-        }else{
-            assert(mb_type & MB_TYPE_L0L1);
-//FIXME decide if MBs in field pictures are MB_TYPE_INTERLACED
-            /* get additionnal motion vector type */
-            if (s->frame_pred_frame_dct)
-                motion_type = MT_FRAME;
-            else{
-                motion_type = get_bits(&s->gb, 2);
-            }
-
-            /* compute dct type */
-            if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?
-                !s->frame_pred_frame_dct && HAS_CBP(mb_type)) {
-                s->interlaced_dct = get_bits1(&s->gb);
-            }
-
-            if (IS_QUANT(mb_type))
-                s->qscale = get_qscale(s);
-
-            /* motion vectors */
-            s->mv_dir = 0;
-            for(i=0;i<2;i++) {
-                if (USES_LIST(mb_type, i)) {
-                    s->mv_dir |= (MV_DIR_FORWARD >> i);
-                    dprintf("motion_type=%d\n", motion_type);
-                    switch(motion_type) {
-                    case MT_FRAME: /* or MT_16X8 */
-                        if (s->picture_structure == PICT_FRAME) {
-                            /* MT_FRAME */
-                            mb_type |= MB_TYPE_16x16;
-                            s->mv_type = MV_TYPE_16X16;
-                            s->mv[i][0][0]= s->last_mv[i][0][0]= s->last_mv[i][1][0] =
-                                mpeg_decode_motion(s, s->mpeg_f_code[i][0], s->last_mv[i][0][0]);
-                            s->mv[i][0][1]= s->last_mv[i][0][1]= s->last_mv[i][1][1] =
-                                mpeg_decode_motion(s, s->mpeg_f_code[i][1], s->last_mv[i][0][1]);
-                            /* full_pel: only for mpeg1 */
-                            if (s->full_pel[i]){
-                                s->mv[i][0][0] <<= 1;
-                                s->mv[i][0][1] <<= 1;
-                            }
-                        } else {
-                            /* MT_16X8 */
-                            mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;
-                            s->mv_type = MV_TYPE_16X8;
-                            for(j=0;j<2;j++) {
-                                s->field_select[i][j] = get_bits1(&s->gb);
-                                for(k=0;k<2;k++) {
-                                    val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],
-                                                             s->last_mv[i][j][k]);
-                                    s->last_mv[i][j][k] = val;
-                                    s->mv[i][j][k] = val;
-                                }
-                            }
-                        }
-                        break;
-                    case MT_FIELD:
-                        s->mv_type = MV_TYPE_FIELD;
-                        if (s->picture_structure == PICT_FRAME) {
-                            mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;
-                            for(j=0;j<2;j++) {
-                                s->field_select[i][j] = get_bits1(&s->gb);
-                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][0],
-                                                         s->last_mv[i][j][0]);
-                                s->last_mv[i][j][0] = val;
-                                s->mv[i][j][0] = val;
-                                dprintf("fmx=%d\n", val);
-                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][1],
-                                                         s->last_mv[i][j][1] >> 1);
-                                s->last_mv[i][j][1] = val << 1;
-                                s->mv[i][j][1] = val;
-                                dprintf("fmy=%d\n", val);
-                            }
-                        } else {
-                            mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED;
-                            s->field_select[i][0] = get_bits1(&s->gb);
-                            for(k=0;k<2;k++) {
-                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],
-                                                         s->last_mv[i][0][k]);
-                                s->last_mv[i][0][k] = val;
-                                s->last_mv[i][1][k] = val;
-                                s->mv[i][0][k] = val;
-                            }
-                        }
-                        break;
-                    case MT_DMV:
-                        {
-                            int dmx, dmy, mx, my, m;
-
-                            mx = mpeg_decode_motion(s, s->mpeg_f_code[i][0],
-                                                    s->last_mv[i][0][0]);
-                            s->last_mv[i][0][0] = mx;
-                            s->last_mv[i][1][0] = mx;
-                            dmx = get_dmv(s);
-                            my = mpeg_decode_motion(s, s->mpeg_f_code[i][1],
-                                                    s->last_mv[i][0][1] >> 1);
-                            dmy = get_dmv(s);
-                            s->mv_type = MV_TYPE_DMV;
-
-
-                            s->last_mv[i][0][1] = my<<1;
-                            s->last_mv[i][1][1] = my<<1;
-
-                            s->mv[i][0][0] = mx;
-                            s->mv[i][0][1] = my;
-                            s->mv[i][1][0] = mx;//not used
-                            s->mv[i][1][1] = my;//not used
-
-                            if (s->picture_structure == PICT_FRAME) {
-                                mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED;
-
-                                //m = 1 + 2 * s->top_field_first;
-                                m = s->top_field_first ? 1 : 3;
-
-                                /* top -> top pred */
-                                s->mv[i][2][0] = ((mx * m + (mx > 0)) >> 1) + dmx;
-                                s->mv[i][2][1] = ((my * m + (my > 0)) >> 1) + dmy - 1;
-                                m = 4 - m;
-                                s->mv[i][3][0] = ((mx * m + (mx > 0)) >> 1) + dmx;
-                                s->mv[i][3][1] = ((my * m + (my > 0)) >> 1) + dmy + 1;
-                            } else {
-                                mb_type |= MB_TYPE_16x16;
-
-                                s->mv[i][2][0] = ((mx + (mx > 0)) >> 1) + dmx;
-                                s->mv[i][2][1] = ((my + (my > 0)) >> 1) + dmy;
-                                if(s->picture_structure == PICT_TOP_FIELD)
-                                    s->mv[i][2][1]--;
-                                else
-                                    s->mv[i][2][1]++;
-                            }
-                        }
-                        break;
-                    default:
-                        av_log(s->avctx, AV_LOG_ERROR, "00 motion_type at %d %d\n", s->mb_x, s->mb_y);
-                        return -1;
-                    }
+                i += run;
+                j = scantable[i];
+                if(level<0){
+                    level= -level;
+                    level= (level*qscale*quant_matrix[j])>>4;
+                    level= (level-1)|1;
+                    level= -level;
+                }else{
+                    level= (level*qscale*quant_matrix[j])>>4;
+                    level= (level-1)|1;
                 }
             }
-        }
-
-        s->mb_intra = 0;
-        if (HAS_CBP(mb_type)) {
-            s->dsp.clear_blocks(s->block[0]);
-
-            if(!s->chroma_y_shift){
-                s->dsp.clear_blocks(s->block[6]);
-            }
-
-            cbp = get_vlc2(&s->gb, mb_pat_vlc.table, MB_PAT_VLC_BITS, 1);
-            if (cbp < 0 || ((cbp == 0) && (s->chroma_format < 2)) ){
-                av_log(s->avctx, AV_LOG_ERROR, "invalid cbp at %d %d\n", s->mb_x, s->mb_y);
+            if (i > 63){
+                av_log(s->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);
                 return -1;
             }
-            if(mb_block_count > 6){
-                 cbp<<= mb_block_count-6;
-                 cbp |= get_bits(&s->gb, mb_block_count-6);
-            }
-
-#ifdef HAVE_XVMC
-            //on 1 we memcpy blocks in xvmcvideo
-            if(s->avctx->xvmc_acceleration > 1){
-                XVMC_pack_pblocks(s,cbp);
-                if(s->swap_uv){
-                    exchange_uv(s);
-                }
-            }
-#endif
-
-            if (s->codec_id == CODEC_ID_MPEG2VIDEO) {
-                if(s->flags2 & CODEC_FLAG2_FAST){
-                    for(i=0;i<6;i++) {
-                        if(cbp & 32) {
-                            mpeg2_fast_decode_block_non_intra(s, s->pblocks[i], i);
-                        } else {
-                            s->block_last_index[i] = -1;
-                        }
-                        cbp+=cbp;
-                    }
-                }else{
-                    cbp<<= 12-mb_block_count;
 
-                    for(i=0;i<mb_block_count;i++) {
-                        if ( cbp & (1<<11) ) {
-                            if (mpeg2_decode_block_non_intra(s, s->pblocks[i], i) < 0)
-                                return -1;
-                        } else {
-                            s->block_last_index[i] = -1;
-                        }
-                        cbp+=cbp;
-                    }
-                }
-            } else {
-                if(s->flags2 & CODEC_FLAG2_FAST){
-                    for(i=0;i<6;i++) {
-                        if (cbp & 32) {
-                            mpeg1_fast_decode_block_inter(s, s->pblocks[i], i);
-                        } else {
-                            s->block_last_index[i] = -1;
-                        }
-                        cbp+=cbp;
-                    }
-                }else{
-                    for(i=0;i<6;i++) {
-                        if (cbp & 32) {
-                            if (mpeg1_decode_block_inter(s, s->pblocks[i], i) < 0)
-                                return -1;
-                        } else {
-                            s->block_last_index[i] = -1;
-                        }
-                        cbp+=cbp;
-                    }
-                }
-            }
-        }else{
-            for(i=0;i<12;i++)
-                s->block_last_index[i] = -1;
+            block[j] = level;
         }
+        CLOSE_READER(re, &s->gb);
     }
-
-    s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= mb_type;
-
-    return 0;
+    s->block_last_index[n] = i;
+   return 0;
 }
 
-/* as h263, but only 17 codes */
-static int mpeg_decode_motion(MpegEncContext *s, int fcode, int pred)
+static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,
+                               DCTELEM *block,
+                               int n)
 {
-    int code, sign, val, l, shift;
-
-    code = get_vlc2(&s->gb, mv_vlc.table, MV_VLC_BITS, 2);
-    if (code == 0) {
-        return pred;
-    }
-    if (code < 0) {
-        return 0xffff;
-    }
+    int level, i, j, run;
+    RLTable *rl = &rl_mpeg1;
+    uint8_t * const scantable= s->intra_scantable.permutated;
+    const int qscale= s->qscale;
+    OPEN_READER(re, &s->gb);
+    i = -1;
 
-    sign = get_bits1(&s->gb);
-    shift = fcode - 1;
-    val = code;
-    if (shift) {
-        val = (val - 1) << shift;
-        val |= get_bits(&s->gb, shift);
-        val++;
+    /* special case for the first coef. no need to add a second vlc table */
+    UPDATE_CACHE(re, &s->gb);
+    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {
+        level= (3*qscale)>>1;
+        if(GET_CACHE(re, &s->gb)&0x40000000)
+            level= -level;
+        block[0] = level;
+        i++;
+        SKIP_BITS(re, &s->gb, 2);
+        if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
+            goto end;
     }
-    if (sign)
-        val = -val;
-    val += pred;
 
-    /* modulo decoding */
-    l= INT_BIT - 5 - shift;
-    val = (val<<l)>>l;
-    return val;
-}
+    /* now quantify & encode AC coefs */
+    for(;;) {
+        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
 
-static inline int decode_dc(GetBitContext *gb, int component)
-{
-    int code, diff;
+        if(level != 0) {
+            i += run;
+            j = scantable[i];
+            level= ((level*2+1)*qscale)>>1;
+            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
+            SKIP_BITS(re, &s->gb, 1);
+        } else {
+            /* escape */
+            run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
+            UPDATE_CACHE(re, &s->gb);
+            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
 
-    if (component == 0) {
-        code = get_vlc2(gb, dc_lum_vlc.table, DC_VLC_BITS, 2);
-    } else {
-        code = get_vlc2(gb, dc_chroma_vlc.table, DC_VLC_BITS, 2);
-    }
-    if (code < 0){
-        av_log(NULL, AV_LOG_ERROR, "invalid dc code at\n");
-        return 0xffff;
-    }
-    if (code == 0) {
-        diff = 0;
-    } else {
-        diff = get_xbits(gb, code);
+            i += run;
+            j = scantable[i];
+            if(level<0){
+                level= ((-level*2+1)*qscale)>>1;
+                level= -level;
+            }else{
+                level= ((level*2+1)*qscale)>>1;
+            }
+        }
+
+        block[j] = level;
+        if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
+            break;
+        UPDATE_CACHE(re, &s->gb);
     }
-    return diff;
+end:
+    LAST_SKIP_BITS(re, &s->gb, 2);
+    CLOSE_READER(re, &s->gb);
+    s->block_last_index[n] = i;
+    return 0;
 }
 
-static inline int mpeg1_decode_block_intra(MpegEncContext *s,
+static inline int mpeg2_decode_block_non_intra(MpegEncContext *s,
                                DCTELEM *block,
                                int n)
 {
-    int level, dc, diff, i, j, run;
-    int component;
+    int level, i, j, run;
     RLTable *rl = &rl_mpeg1;
     uint8_t * const scantable= s->intra_scantable.permutated;
-    const uint16_t *quant_matrix= s->intra_matrix;
+    const uint16_t *quant_matrix;
     const int qscale= s->qscale;
+    int mismatch;
+
+    mismatch = 1;
 
-    /* DC coef */
-    component = (n <= 3 ? 0 : n - 4 + 1);
-    diff = decode_dc(&s->gb, component);
-    if (diff >= 0xffff)
-        return -1;
-    dc = s->last_dc[component];
-    dc += diff;
-    s->last_dc[component] = dc;
-    block[0] = dc<<3;
-    dprintf("dc=%d diff=%d\n", dc, diff);
-    i = 0;
     {
         OPEN_READER(re, &s->gb);
+        i = -1;
+        if (n < 4)
+            quant_matrix = s->inter_matrix;
+        else
+            quant_matrix = s->chroma_inter_matrix;
+
+        /* special case for the first coef. no need to add a second vlc table */
+        UPDATE_CACHE(re, &s->gb);
+        if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {
+            level= (3*qscale*quant_matrix[0])>>5;
+            if(GET_CACHE(re, &s->gb)&0x40000000)
+                level= -level;
+            block[0] = level;
+            mismatch ^= level;
+            i++;
+            SKIP_BITS(re, &s->gb, 2);
+            if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
+                goto end;
+        }
+
         /* now quantify & encode AC coefs */
         for(;;) {
-            UPDATE_CACHE(re, &s->gb);
             GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
 
-            if(level == 127){
-                break;
-            } else if(level != 0) {
+            if(level != 0) {
                 i += run;
                 j = scantable[i];
-                level= (level*qscale*quant_matrix[j])>>4;
-                level= (level-1)|1;
+                level= ((level*2+1)*qscale*quant_matrix[j])>>5;
                 level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
-                LAST_SKIP_BITS(re, &s->gb, 1);
+                SKIP_BITS(re, &s->gb, 1);
             } else {
                 /* escape */
                 run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
                 UPDATE_CACHE(re, &s->gb);
-                level = SHOW_SBITS(re, &s->gb, 8); SKIP_BITS(re, &s->gb, 8);
-                if (level == -128) {
-                    level = SHOW_UBITS(re, &s->gb, 8) - 256; LAST_SKIP_BITS(re, &s->gb, 8);
-                } else if (level == 0) {
-                    level = SHOW_UBITS(re, &s->gb, 8)      ; LAST_SKIP_BITS(re, &s->gb, 8);
-                }
+                level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
+
                 i += run;
                 j = scantable[i];
                 if(level<0){
-                    level= -level;
-                    level= (level*qscale*quant_matrix[j])>>4;
-                    level= (level-1)|1;
+                    level= ((-level*2+1)*qscale*quant_matrix[j])>>5;
                     level= -level;
                 }else{
-                    level= (level*qscale*quant_matrix[j])>>4;
-                    level= (level-1)|1;
+                    level= ((level*2+1)*qscale*quant_matrix[j])>>5;
                 }
             }
             if (i > 63){
@@ -1590,12 +1445,20 @@ static inline int mpeg1_decode_block_int
                 return -1;
             }
 
+            mismatch ^= level;
             block[j] = level;
+            if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
+                break;
+            UPDATE_CACHE(re, &s->gb);
         }
+end:
+        LAST_SKIP_BITS(re, &s->gb, 2);
         CLOSE_READER(re, &s->gb);
     }
+    block[63] ^= (mismatch & 1);
+
     s->block_last_index[n] = i;
-   return 0;
+    return 0;
 }
 
 static inline int mpeg1_decode_block_inter(MpegEncContext *s,
@@ -1733,315 +1596,452 @@ static inline int mpeg1_fast_decode_bloc
                     level= (level-1)|1;
                 }
             }
-
-            block[j] = level;
-            if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
-                break;
-            UPDATE_CACHE(re, &s->gb);
+
+            block[j] = level;
+            if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
+                break;
+            UPDATE_CACHE(re, &s->gb);
+        }
+end:
+        LAST_SKIP_BITS(re, &s->gb, 2);
+        CLOSE_READER(re, &s->gb);
+    }
+    s->block_last_index[n] = i;
+    return 0;
+}
+
+static int mpeg_decode_mb(MpegEncContext *s,
+                          DCTELEM block[12][64])
+{
+    int i, j, k, cbp, val, mb_type, motion_type;
+    const int mb_block_count = 4 + (1<< s->chroma_format);
+
+    dprintf("decode_mb: x=%d y=%d\n", s->mb_x, s->mb_y);
+
+    assert(s->mb_skipped==0);
+
+    if (s->mb_skip_run-- != 0) {
+        if(s->pict_type == I_TYPE){
+            av_log(s->avctx, AV_LOG_ERROR, "skipped MB in I frame at %d %d\n", s->mb_x, s->mb_y);
+            return -1;
+        }
+
+        /* skip mb */
+        s->mb_intra = 0;
+        for(i=0;i<12;i++)
+            s->block_last_index[i] = -1;
+        if(s->picture_structure == PICT_FRAME)
+            s->mv_type = MV_TYPE_16X16;
+        else
+            s->mv_type = MV_TYPE_FIELD;
+        if (s->pict_type == P_TYPE) {
+            /* if P type, zero motion vector is implied */
+            s->mv_dir = MV_DIR_FORWARD;
+            s->mv[0][0][0] = s->mv[0][0][1] = 0;
+            s->last_mv[0][0][0] = s->last_mv[0][0][1] = 0;
+            s->last_mv[0][1][0] = s->last_mv[0][1][1] = 0;
+            s->field_select[0][0]= s->picture_structure - 1;
+            s->mb_skipped = 1;
+            s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= MB_TYPE_SKIP | MB_TYPE_L0 | MB_TYPE_16x16;
+        } else {
+            int mb_type;
+
+            if(s->mb_x)
+                mb_type= s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride - 1];
+            else
+                mb_type= s->current_picture.mb_type[ s->mb_width + (s->mb_y-1)*s->mb_stride - 1]; // FIXME not sure if this is allowed in mpeg at all,
+            if(IS_INTRA(mb_type))
+                return -1;
+
+            /* if B type, reuse previous vectors and directions */
+            s->mv[0][0][0] = s->last_mv[0][0][0];
+            s->mv[0][0][1] = s->last_mv[0][0][1];
+            s->mv[1][0][0] = s->last_mv[1][0][0];
+            s->mv[1][0][1] = s->last_mv[1][0][1];
+
+            s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]=
+                mb_type | MB_TYPE_SKIP;
+//            assert(s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride - 1]&(MB_TYPE_16x16|MB_TYPE_16x8));
+
+            if((s->mv[0][0][0]|s->mv[0][0][1]|s->mv[1][0][0]|s->mv[1][0][1])==0)
+                s->mb_skipped = 1;
+        }
+
+        return 0;
+    }
+
+    switch(s->pict_type) {
+    default:
+    case I_TYPE:
+        if (get_bits1(&s->gb) == 0) {
+            if (get_bits1(&s->gb) == 0){
+                av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in I Frame at %d %d\n", s->mb_x, s->mb_y);
+                return -1;
+            }
+            mb_type = MB_TYPE_QUANT | MB_TYPE_INTRA;
+        } else {
+            mb_type = MB_TYPE_INTRA;
+        }
+        break;
+    case P_TYPE:
+        mb_type = get_vlc2(&s->gb, mb_ptype_vlc.table, MB_PTYPE_VLC_BITS, 1);
+        if (mb_type < 0){
+            av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in P Frame at %d %d\n", s->mb_x, s->mb_y);
+            return -1;
+        }
+        mb_type = ptype2mb_type[ mb_type ];
+        break;
+    case B_TYPE:
+        mb_type = get_vlc2(&s->gb, mb_btype_vlc.table, MB_BTYPE_VLC_BITS, 1);
+        if (mb_type < 0){
+            av_log(s->avctx, AV_LOG_ERROR, "invalid mb type in B Frame at %d %d\n", s->mb_x, s->mb_y);
+            return -1;
+        }
+        mb_type = btype2mb_type[ mb_type ];
+        break;
+    }
+    dprintf("mb_type=%x\n", mb_type);
+//    motion_type = 0; /* avoid warning */
+    if (IS_INTRA(mb_type)) {
+        s->dsp.clear_blocks(s->block[0]);
+
+        if(!s->chroma_y_shift){
+            s->dsp.clear_blocks(s->block[6]);
+        }
+
+        /* compute dct type */
+        if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?
+            !s->frame_pred_frame_dct) {
+            s->interlaced_dct = get_bits1(&s->gb);
+        }
+
+        if (IS_QUANT(mb_type))
+            s->qscale = get_qscale(s);
+
+        if (s->concealment_motion_vectors) {
+            /* just parse them */
+            if (s->picture_structure != PICT_FRAME)
+                skip_bits1(&s->gb); /* field select */
+
+            s->mv[0][0][0]= s->last_mv[0][0][0]= s->last_mv[0][1][0] =
+                mpeg_decode_motion(s, s->mpeg_f_code[0][0], s->last_mv[0][0][0]);
+            s->mv[0][0][1]= s->last_mv[0][0][1]= s->last_mv[0][1][1] =
+                mpeg_decode_motion(s, s->mpeg_f_code[0][1], s->last_mv[0][0][1]);
+
+            skip_bits1(&s->gb); /* marker */
+        }else
+            memset(s->last_mv, 0, sizeof(s->last_mv)); /* reset mv prediction */
+        s->mb_intra = 1;
+#ifdef HAVE_XVMC
+        //one 1 we memcpy blocks in xvmcvideo
+        if(s->avctx->xvmc_acceleration > 1){
+            XVMC_pack_pblocks(s,-1);//inter are always full blocks
+            if(s->swap_uv){
+                exchange_uv(s);
+            }
+        }
+#endif
+
+        if (s->codec_id == CODEC_ID_MPEG2VIDEO) {
+            if(s->flags2 & CODEC_FLAG2_FAST){
+                for(i=0;i<6;i++) {
+                    mpeg2_fast_decode_block_intra(s, s->pblocks[i], i);
+                }
+            }else{
+                for(i=0;i<mb_block_count;i++) {
+                    if (mpeg2_decode_block_intra(s, s->pblocks[i], i) < 0)
+                        return -1;
+                }
+            }
+        } else {
+            for(i=0;i<6;i++) {
+                if (mpeg1_decode_block_intra(s, s->pblocks[i], i) < 0)
+                    return -1;
+            }
         }
-end:
-        LAST_SKIP_BITS(re, &s->gb, 2);
-        CLOSE_READER(re, &s->gb);
-    }
-    s->block_last_index[n] = i;
-    return 0;
-}
-
+    } else {
+        if (mb_type & MB_TYPE_ZERO_MV){
+            assert(mb_type & MB_TYPE_CBP);
 
-static inline int mpeg2_decode_block_non_intra(MpegEncContext *s,
-                               DCTELEM *block,
-                               int n)
-{
-    int level, i, j, run;
-    RLTable *rl = &rl_mpeg1;
-    uint8_t * const scantable= s->intra_scantable.permutated;
-    const uint16_t *quant_matrix;
-    const int qscale= s->qscale;
-    int mismatch;
+            /* compute dct type */
+            if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?
+                !s->frame_pred_frame_dct) {
+                s->interlaced_dct = get_bits1(&s->gb);
+            }
 
-    mismatch = 1;
+            if (IS_QUANT(mb_type))
+                s->qscale = get_qscale(s);
 
-    {
-        OPEN_READER(re, &s->gb);
-        i = -1;
-        if (n < 4)
-            quant_matrix = s->inter_matrix;
-        else
-            quant_matrix = s->chroma_inter_matrix;
+            s->mv_dir = MV_DIR_FORWARD;
+            if(s->picture_structure == PICT_FRAME)
+                s->mv_type = MV_TYPE_16X16;
+            else{
+                s->mv_type = MV_TYPE_FIELD;
+                mb_type |= MB_TYPE_INTERLACED;
+                s->field_select[0][0]= s->picture_structure - 1;
+            }
+            s->last_mv[0][0][0] = 0;
+            s->last_mv[0][0][1] = 0;
+            s->last_mv[0][1][0] = 0;
+            s->last_mv[0][1][1] = 0;
+            s->mv[0][0][0] = 0;
+            s->mv[0][0][1] = 0;
+        }else{
+            assert(mb_type & MB_TYPE_L0L1);
+//FIXME decide if MBs in field pictures are MB_TYPE_INTERLACED
+            /* get additionnal motion vector type */
+            if (s->frame_pred_frame_dct)
+                motion_type = MT_FRAME;
+            else{
+                motion_type = get_bits(&s->gb, 2);
+            }
 
-        /* special case for the first coef. no need to add a second vlc table */
-        UPDATE_CACHE(re, &s->gb);
-        if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {
-            level= (3*qscale*quant_matrix[0])>>5;
-            if(GET_CACHE(re, &s->gb)&0x40000000)
-                level= -level;
-            block[0] = level;
-            mismatch ^= level;
-            i++;
-            SKIP_BITS(re, &s->gb, 2);
-            if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
-                goto end;
-        }
+            /* compute dct type */
+            if (s->picture_structure == PICT_FRAME && //FIXME add a interlaced_dct coded var?
+                !s->frame_pred_frame_dct && HAS_CBP(mb_type)) {
+                s->interlaced_dct = get_bits1(&s->gb);
+            }
 
-        /* now quantify & encode AC coefs */
-        for(;;) {
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
+            if (IS_QUANT(mb_type))
+                s->qscale = get_qscale(s);
 
-            if(level != 0) {
-                i += run;
-                j = scantable[i];
-                level= ((level*2+1)*qscale*quant_matrix[j])>>5;
-                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
-                SKIP_BITS(re, &s->gb, 1);
-            } else {
-                /* escape */
-                run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
-                UPDATE_CACHE(re, &s->gb);
-                level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
+            /* motion vectors */
+            s->mv_dir = 0;
+            for(i=0;i<2;i++) {
+                if (USES_LIST(mb_type, i)) {
+                    s->mv_dir |= (MV_DIR_FORWARD >> i);
+                    dprintf("motion_type=%d\n", motion_type);
+                    switch(motion_type) {
+                    case MT_FRAME: /* or MT_16X8 */
+                        if (s->picture_structure == PICT_FRAME) {
+                            /* MT_FRAME */
+                            mb_type |= MB_TYPE_16x16;
+                            s->mv_type = MV_TYPE_16X16;
+                            s->mv[i][0][0]= s->last_mv[i][0][0]= s->last_mv[i][1][0] =
+                                mpeg_decode_motion(s, s->mpeg_f_code[i][0], s->last_mv[i][0][0]);
+                            s->mv[i][0][1]= s->last_mv[i][0][1]= s->last_mv[i][1][1] =
+                                mpeg_decode_motion(s, s->mpeg_f_code[i][1], s->last_mv[i][0][1]);
+                            /* full_pel: only for mpeg1 */
+                            if (s->full_pel[i]){
+                                s->mv[i][0][0] <<= 1;
+                                s->mv[i][0][1] <<= 1;
+                            }
+                        } else {
+                            /* MT_16X8 */
+                            mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;
+                            s->mv_type = MV_TYPE_16X8;
+                            for(j=0;j<2;j++) {
+                                s->field_select[i][j] = get_bits1(&s->gb);
+                                for(k=0;k<2;k++) {
+                                    val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],
+                                                             s->last_mv[i][j][k]);
+                                    s->last_mv[i][j][k] = val;
+                                    s->mv[i][j][k] = val;
+                                }
+                            }
+                        }
+                        break;
+                    case MT_FIELD:
+                        s->mv_type = MV_TYPE_FIELD;
+                        if (s->picture_structure == PICT_FRAME) {
+                            mb_type |= MB_TYPE_16x8 | MB_TYPE_INTERLACED;
+                            for(j=0;j<2;j++) {
+                                s->field_select[i][j] = get_bits1(&s->gb);
+                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][0],
+                                                         s->last_mv[i][j][0]);
+                                s->last_mv[i][j][0] = val;
+                                s->mv[i][j][0] = val;
+                                dprintf("fmx=%d\n", val);
+                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][1],
+                                                         s->last_mv[i][j][1] >> 1);
+                                s->last_mv[i][j][1] = val << 1;
+                                s->mv[i][j][1] = val;
+                                dprintf("fmy=%d\n", val);
+                            }
+                        } else {
+                            mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED;
+                            s->field_select[i][0] = get_bits1(&s->gb);
+                            for(k=0;k<2;k++) {
+                                val = mpeg_decode_motion(s, s->mpeg_f_code[i][k],
+                                                         s->last_mv[i][0][k]);
+                                s->last_mv[i][0][k] = val;
+                                s->last_mv[i][1][k] = val;
+                                s->mv[i][0][k] = val;
+                            }
+                        }
+                        break;
+                    case MT_DMV:
+                        {
+                            int dmx, dmy, mx, my, m;
 
-                i += run;
-                j = scantable[i];
-                if(level<0){
-                    level= ((-level*2+1)*qscale*quant_matrix[j])>>5;
-                    level= -level;
-                }else{
-                    level= ((level*2+1)*qscale*quant_matrix[j])>>5;
-                }
-            }
-            if (i > 63){
-                av_log(s->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);
-                return -1;
-            }
+                            mx = mpeg_decode_motion(s, s->mpeg_f_code[i][0],
+                                                    s->last_mv[i][0][0]);
+                            s->last_mv[i][0][0] = mx;
+                            s->last_mv[i][1][0] = mx;
+                            dmx = get_dmv(s);
+                            my = mpeg_decode_motion(s, s->mpeg_f_code[i][1],
+                                                    s->last_mv[i][0][1] >> 1);
+                            dmy = get_dmv(s);
+                            s->mv_type = MV_TYPE_DMV;
 
-            mismatch ^= level;
-            block[j] = level;
-            if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
-                break;
-            UPDATE_CACHE(re, &s->gb);
-        }
-end:
-        LAST_SKIP_BITS(re, &s->gb, 2);
-        CLOSE_READER(re, &s->gb);
-    }
-    block[63] ^= (mismatch & 1);
 
-    s->block_last_index[n] = i;
-    return 0;
-}
+                            s->last_mv[i][0][1] = my<<1;
+                            s->last_mv[i][1][1] = my<<1;
 
-static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,
-                               DCTELEM *block,
-                               int n)
-{
-    int level, i, j, run;
-    RLTable *rl = &rl_mpeg1;
-    uint8_t * const scantable= s->intra_scantable.permutated;
-    const int qscale= s->qscale;
-    OPEN_READER(re, &s->gb);
-    i = -1;
+                            s->mv[i][0][0] = mx;
+                            s->mv[i][0][1] = my;
+                            s->mv[i][1][0] = mx;//not used
+                            s->mv[i][1][1] = my;//not used
 
-    /* special case for the first coef. no need to add a second vlc table */
-    UPDATE_CACHE(re, &s->gb);
-    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {
-        level= (3*qscale)>>1;
-        if(GET_CACHE(re, &s->gb)&0x40000000)
-            level= -level;
-        block[0] = level;
-        i++;
-        SKIP_BITS(re, &s->gb, 2);
-        if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
-            goto end;
-    }
+                            if (s->picture_structure == PICT_FRAME) {
+                                mb_type |= MB_TYPE_16x16 | MB_TYPE_INTERLACED;
 
-    /* now quantify & encode AC coefs */
-    for(;;) {
-        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
+                                //m = 1 + 2 * s->top_field_first;
+                                m = s->top_field_first ? 1 : 3;
 
-        if(level != 0) {
-            i += run;
-            j = scantable[i];
-            level= ((level*2+1)*qscale)>>1;
-            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
-            SKIP_BITS(re, &s->gb, 1);
-        } else {
-            /* escape */
-            run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
-            UPDATE_CACHE(re, &s->gb);
-            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
+                                /* top -> top pred */
+                                s->mv[i][2][0] = ((mx * m + (mx > 0)) >> 1) + dmx;
+                                s->mv[i][2][1] = ((my * m + (my > 0)) >> 1) + dmy - 1;
+                                m = 4 - m;
+                                s->mv[i][3][0] = ((mx * m + (mx > 0)) >> 1) + dmx;
+                                s->mv[i][3][1] = ((my * m + (my > 0)) >> 1) + dmy + 1;
+                            } else {
+                                mb_type |= MB_TYPE_16x16;
 
-            i += run;
-            j = scantable[i];
-            if(level<0){
-                level= ((-level*2+1)*qscale)>>1;
-                level= -level;
-            }else{
-                level= ((level*2+1)*qscale)>>1;
+                                s->mv[i][2][0] = ((mx + (mx > 0)) >> 1) + dmx;
+                                s->mv[i][2][1] = ((my + (my > 0)) >> 1) + dmy;
+                                if(s->picture_structure == PICT_TOP_FIELD)
+                                    s->mv[i][2][1]--;
+                                else
+                                    s->mv[i][2][1]++;
+                            }
+                        }
+                        break;
+                    default:
+                        av_log(s->avctx, AV_LOG_ERROR, "00 motion_type at %d %d\n", s->mb_x, s->mb_y);
+                        return -1;
+                    }
+                }
             }
         }
 
-        block[j] = level;
-        if(((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)
-            break;
-        UPDATE_CACHE(re, &s->gb);
-    }
-end:
-    LAST_SKIP_BITS(re, &s->gb, 2);
-    CLOSE_READER(re, &s->gb);
-    s->block_last_index[n] = i;
-    return 0;
-}
+        s->mb_intra = 0;
+        if (HAS_CBP(mb_type)) {
+            s->dsp.clear_blocks(s->block[0]);
 
+            if(!s->chroma_y_shift){
+                s->dsp.clear_blocks(s->block[6]);
+            }
 
-static inline int mpeg2_decode_block_intra(MpegEncContext *s,
-                               DCTELEM *block,
-                               int n)
-{
-    int level, dc, diff, i, j, run;
-    int component;
-    RLTable *rl;
-    uint8_t * const scantable= s->intra_scantable.permutated;
-    const uint16_t *quant_matrix;
-    const int qscale= s->qscale;
-    int mismatch;
+            cbp = get_vlc2(&s->gb, mb_pat_vlc.table, MB_PAT_VLC_BITS, 1);
+            if (cbp < 0 || ((cbp == 0) && (s->chroma_format < 2)) ){
+                av_log(s->avctx, AV_LOG_ERROR, "invalid cbp at %d %d\n", s->mb_x, s->mb_y);
+                return -1;
+            }
+            if(mb_block_count > 6){
+                 cbp<<= mb_block_count-6;
+                 cbp |= get_bits(&s->gb, mb_block_count-6);
+            }
 
-    /* DC coef */
-    if (n < 4){
-        quant_matrix = s->intra_matrix;
-        component = 0;
-    }else{
-        quant_matrix = s->chroma_intra_matrix;
-        component = (n&1) + 1;
-    }
-    diff = decode_dc(&s->gb, component);
-    if (diff >= 0xffff)
-        return -1;
-    dc = s->last_dc[component];
-    dc += diff;
-    s->last_dc[component] = dc;
-    block[0] = dc << (3 - s->intra_dc_precision);
-    dprintf("dc=%d\n", block[0]);
-    mismatch = block[0] ^ 1;
-    i = 0;
-    if (s->intra_vlc_format)
-        rl = &rl_mpeg2;
-    else
-        rl = &rl_mpeg1;
+#ifdef HAVE_XVMC
+            //on 1 we memcpy blocks in xvmcvideo
+            if(s->avctx->xvmc_acceleration > 1){
+                XVMC_pack_pblocks(s,cbp);
+                if(s->swap_uv){
+                    exchange_uv(s);
+                }
+            }
+#endif
 
-    {
-        OPEN_READER(re, &s->gb);
-        /* now quantify & encode AC coefs */
-        for(;;) {
-            UPDATE_CACHE(re, &s->gb);
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
+            if (s->codec_id == CODEC_ID_MPEG2VIDEO) {
+                if(s->flags2 & CODEC_FLAG2_FAST){
+                    for(i=0;i<6;i++) {
+                        if(cbp & 32) {
+                            mpeg2_fast_decode_block_non_intra(s, s->pblocks[i], i);
+                        } else {
+                            s->block_last_index[i] = -1;
+                        }
+                        cbp+=cbp;
+                    }
+                }else{
+                    cbp<<= 12-mb_block_count;
 
-            if(level == 127){
-                break;
-            } else if(level != 0) {
-                i += run;
-                j = scantable[i];
-                level= (level*qscale*quant_matrix[j])>>4;
-                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
-                LAST_SKIP_BITS(re, &s->gb, 1);
+                    for(i=0;i<mb_block_count;i++) {
+                        if ( cbp & (1<<11) ) {
+                            if (mpeg2_decode_block_non_intra(s, s->pblocks[i], i) < 0)
+                                return -1;
+                        } else {
+                            s->block_last_index[i] = -1;
+                        }
+                        cbp+=cbp;
+                    }
+                }
             } else {
-                /* escape */
-                run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
-                UPDATE_CACHE(re, &s->gb);
-                level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
-                i += run;
-                j = scantable[i];
-                if(level<0){
-                    level= (-level*qscale*quant_matrix[j])>>4;
-                    level= -level;
+                if(s->flags2 & CODEC_FLAG2_FAST){
+                    for(i=0;i<6;i++) {
+                        if (cbp & 32) {
+                            mpeg1_fast_decode_block_inter(s, s->pblocks[i], i);
+                        } else {
+                            s->block_last_index[i] = -1;
+                        }
+                        cbp+=cbp;
+                    }
                 }else{
-                    level= (level*qscale*quant_matrix[j])>>4;
+                    for(i=0;i<6;i++) {
+                        if (cbp & 32) {
+                            if (mpeg1_decode_block_inter(s, s->pblocks[i], i) < 0)
+                                return -1;
+                        } else {
+                            s->block_last_index[i] = -1;
+                        }
+                        cbp+=cbp;
+                    }
                 }
             }
-            if (i > 63){
-                av_log(s->avctx, AV_LOG_ERROR, "ac-tex damaged at %d %d\n", s->mb_x, s->mb_y);
-                return -1;
-            }
-
-            mismatch^= level;
-            block[j] = level;
+        }else{
+            for(i=0;i<12;i++)
+                s->block_last_index[i] = -1;
         }
-        CLOSE_READER(re, &s->gb);
     }
-    block[63]^= mismatch&1;
 
-    s->block_last_index[n] = i;
+    s->current_picture.mb_type[ s->mb_x + s->mb_y*s->mb_stride ]= mb_type;
+
     return 0;
 }
 
-static inline int mpeg2_fast_decode_block_intra(MpegEncContext *s,
-                               DCTELEM *block,
-                               int n)
+/* as h263, but only 17 codes */
+static int mpeg_decode_motion(MpegEncContext *s, int fcode, int pred)
 {
-    int level, dc, diff, j, run;
-    int component;
-    RLTable *rl;
-    uint8_t * scantable= s->intra_scantable.permutated;
-    const uint16_t *quant_matrix;
-    const int qscale= s->qscale;
+    int code, sign, val, l, shift;
 
-    /* DC coef */
-    if (n < 4){
-        quant_matrix = s->intra_matrix;
-        component = 0;
-    }else{
-        quant_matrix = s->chroma_intra_matrix;
-        component = (n&1) + 1;
+    code = get_vlc2(&s->gb, mv_vlc.table, MV_VLC_BITS, 2);
+    if (code == 0) {
+        return pred;
+    }
+    if (code < 0) {
+        return 0xffff;
     }
-    diff = decode_dc(&s->gb, component);
-    if (diff >= 0xffff)
-        return -1;
-    dc = s->last_dc[component];
-    dc += diff;
-    s->last_dc[component] = dc;
-    block[0] = dc << (3 - s->intra_dc_precision);
-    if (s->intra_vlc_format)
-        rl = &rl_mpeg2;
-    else
-        rl = &rl_mpeg1;
-
-    {
-        OPEN_READER(re, &s->gb);
-        /* now quantify & encode AC coefs */
-        for(;;) {
-            UPDATE_CACHE(re, &s->gb);
-            GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);
-
-            if(level == 127){
-                break;
-            } else if(level != 0) {
-                scantable += run;
-                j = *scantable;
-                level= (level*qscale*quant_matrix[j])>>4;
-                level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);
-                LAST_SKIP_BITS(re, &s->gb, 1);
-            } else {
-                /* escape */
-                run = SHOW_UBITS(re, &s->gb, 6)+1; LAST_SKIP_BITS(re, &s->gb, 6);
-                UPDATE_CACHE(re, &s->gb);
-                level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);
-                scantable += run;
-                j = *scantable;
-                if(level<0){
-                    level= (-level*qscale*quant_matrix[j])>>4;
-                    level= -level;
-                }else{
-                    level= (level*qscale*quant_matrix[j])>>4;
-                }
-            }
 
-            block[j] = level;
-        }
-        CLOSE_READER(re, &s->gb);
+    sign = get_bits1(&s->gb);
+    shift = fcode - 1;
+    val = code;
+    if (shift) {
+        val = (val - 1) << shift;
+        val |= get_bits(&s->gb, shift);
+        val++;
     }
+    if (sign)
+        val = -val;
+    val += pred;
 
-    s->block_last_index[n] = scantable - s->intra_scantable.permutated;
-    return 0;
+    /* modulo decoding */
+    l= INT_BIT - 5 - shift;
+    val = (val<<l)>>l;
+    return val;
 }
 
+
+
 typedef struct Mpeg1Context {
     MpegEncContext mpeg_enc_ctx;
     int mpeg_enc_ctx_allocated; /* true if decoding context allocated */
