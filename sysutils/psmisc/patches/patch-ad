$NetBSD: patch-ad,v 1.3 2000/03/17 15:54:53 jlam Exp $

--- pstree.c.orig	Sat May  1 15:40:56 1999
+++ pstree.c	Thu Mar 16 23:22:45 2000
@@ -2,6 +2,9 @@
 
 /* Copyright 1993-1999 Werner Almesberger. See file COPYING for details. */
 
+#ifdef linux
+#define HAVE_GETOPT_H
+#endif
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -9,17 +12,26 @@
 #include <ctype.h>
 #include <unistd.h>
 #include <fcntl.h>
+#ifdef HAVE_GETOPT_H
 #include <getopt.h>
+#endif
 #include <pwd.h>
 #include <dirent.h>
 #include <termios.h>
 #include <termcap.h>
+#include <sys/param.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 
 #include "comm.h"
 
+#if (defined(BSD) && BSD >= 199306)
+#define BSD_44_PROC
+#if (defined(__NetBSD_Version__) && __NetBSD_Version__ >= 104180000)
+#define BSD_PROC_CMDLINE
+#endif
+#endif
 
 #ifndef MAX_DEPTH
 #define MAX_DEPTH    100
@@ -252,6 +264,7 @@
     const struct passwd *pw;
     int lvl,i,add,offset,len,swapped,info,count,comm_len,first;
     const char *tmp,*here;
+    char tbuf[1024], *pbuf;
     char comm_tmp[5];
 
     if (!current) return;
@@ -270,7 +283,8 @@
 	add = out_int(rep)+2;
 	out_string("*[");
     }
-    if (current->highlight && (tmp = tgetstr("md",NULL))) tputs(tmp,1,putchar);
+    pbuf = tbuf;
+    if (current->highlight && (tmp = tgetstr("md",&pbuf))) tputs(tmp,1,putchar);
     if (swapped = print_args && current->argc < 0) out_char('(');
     comm_len = 0;
     for (here = current->comm; *here; here++)
@@ -297,7 +311,8 @@
 	else (void) out_int(current->uid);
     }
     if (info || swapped) out_char(')');
-    if (current->highlight && (tmp = tgetstr("me",NULL))) tputs(tmp,1,putchar);
+    pbuf = tbuf;
+    if (current->highlight && (tmp = tgetstr("me",&pbuf))) tputs(tmp,1,putchar);
     if (print_args) {
 	for (i = 0; i < current->argc; i++) {
 	    out_char(' ');
@@ -387,8 +402,11 @@
     char path[PATH_MAX+1],comm[COMM_LEN+1];
     char *buffer;
     pid_t pid,ppid;
+#if !defined(BSD_44_PROC) || defined(BSD_PROC_CMDLINE)
     int fd,size;
-    int empty,dummy;
+    int dummy;
+#endif
+    int empty;
 
     if (!print_args) buffer = NULL;
     else if (!(buffer = malloc((size_t) (output_width+1)))) {
@@ -402,15 +420,26 @@
     empty = 1;
     while (de = readdir(dir))
 	if (pid = atoi(de->d_name)) {
+#ifdef BSD_44_PROC
+	    sprintf(path,"%s/%d/status",PROC_BASE,pid);
+#else
 	    sprintf(path,"%s/%d/stat",PROC_BASE,pid);
+#endif
 	    if (file = fopen(path,"r")) {
 		empty = 0;
 		if (fstat(fileno(file),&st) < 0) {
 		    perror(path);
 		    exit(1);
 		}
+#ifdef BSD_44_PROC
+		if (fscanf(file,"%s %*d %d",comm,&ppid) == 2) {
+#else
 		if (fscanf(file,"%d (%[^)]) %c %d",&dummy,comm,(char *) &dummy,
 		  &ppid) == 4) {
+#endif
+#if defined(BSD_44_PROC) && !defined(BSD_PROC_CMDLINE)
+		    add_proc(comm,pid,ppid,st,st_uid,NULL,0);
+#else
 		    if (!print_args) add_proc(comm,pid,ppid,st.st_uid,NULL,0);
 		    else {
 			sprintf(path,"%s/%d/cmdline",PROC_BASE,pid);
@@ -426,6 +455,7 @@
 			(void) close(fd);
 			if (size) buffer[size++] = 0;
 			add_proc(comm,pid,ppid,st.st_uid,buffer,size);
+#endif
 		    }
 		}
 		(void) fclose(file);
