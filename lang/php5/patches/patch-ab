$NetBSD: patch-ab,v 1.4 2007/04/29 12:30:18 taca Exp $

--- TSRM/tsrm_virtual_cwd.c.orig	2007-04-28 22:51:43.000000000 +0100
+++ TSRM/tsrm_virtual_cwd.c	2007-04-28 22:52:15.000000000 +0100
@@ -474,7 +474,11 @@
 	realpath_cache_bucket *bucket;
 	time_t t = 0;
 	int ret;
+	int use_cache;
+	int use_relative_path = 0;
 	TSRMLS_FETCH();
+	
+	use_cache = ((use_realpath != CWD_EXPAND) && CWDG(realpath_cache_size_limit));
 
 	if (path_length == 0) 
 		return (0);
@@ -488,27 +492,32 @@
 	/* cwd_length can be 0 when getcwd() fails.
 	 * This can happen under solaris when a dir does not have read permissions
 	 * but *does* have execute permissions */
-	if (!IS_ABSOLUTE_PATH(path, path_length) && (state->cwd_length > 0)) {
-		int orig_path_len;
-		int state_cwd_length = state->cwd_length;
+	if (!IS_ABSOLUTE_PATH(path, path_length)) {
+		if (state->cwd_length == 0) {
+			use_cache = 0;
+			use_relative_path = 1;
+		} else {
+			int orig_path_len;
+			int state_cwd_length = state->cwd_length;
 
 #ifdef TSRM_WIN32
-		if (IS_SLASH(path[0])) {
-			state_cwd_length = 2;
-		}
+			if (IS_SLASH(path[0])) {
+				state_cwd_length = 2;
+			}
 #endif
-		orig_path_len = path_length + state_cwd_length + 1;
-		if (orig_path_len >= MAXPATHLEN) {
-			return 1;
+			orig_path_len = path_length + state_cwd_length + 1;
+			if (orig_path_len >= MAXPATHLEN) {
+				return 1;
+			}
+			memcpy(orig_path, state->cwd, state_cwd_length);
+			orig_path[state_cwd_length] = DEFAULT_SLASH;
+			memcpy(orig_path + state_cwd_length + 1, path, path_length + 1);
+			path = orig_path;
+			path_length = orig_path_len; 
 		}
-		memcpy(orig_path, state->cwd, state_cwd_length);
-		orig_path[state_cwd_length] = DEFAULT_SLASH;
-		memcpy(orig_path + state_cwd_length + 1, path, path_length + 1);
-		path = orig_path;
-		path_length = orig_path_len; 
 	}
 
-	if (use_realpath != CWD_EXPAND && CWDG(realpath_cache_size_limit)) {
+	if (use_cache) {
 		t = CWDG(realpath_cache_ttl)?time(NULL):0;
 		if ((bucket = realpath_cache_find(path, path_length, t TSRMLS_CC)) != NULL) {		
 			int len = bucket->realpath_len;
@@ -548,18 +557,19 @@
 #endif
 	} else {
 		char *ptr, *path_copy, *free_path;
-		char *tok = NULL;
+		char *tok;
 		int ptr_length;
 #ifdef TSRM_WIN32
-		int is_unc = 0;
+		int is_unc;
 #endif
-
 no_realpath:
 
 		free_path = path_copy = tsrm_strndup(path, path_length);
 		CWD_STATE_COPY(&old_state, state);
 
-#ifdef TSRM_WIN32		
+#ifdef TSRM_WIN32
+		ret = 0;
+		is_unc = 0;
 		if (path_length >= 2 && path[1] == ':') {			
 			state->cwd = (char *) realloc(state->cwd, 2 + 1);
 			state->cwd[0] = toupper(path[0]);
@@ -583,6 +593,7 @@
 		}
 #endif
 		
+		tok = NULL;
 		ptr = tsrm_strtok_r(path_copy, TOKENIZER_STRING, &tok);
 		while (ptr) {
 			ptr_length = strlen(ptr);
@@ -590,6 +601,12 @@
 			if (IS_DIRECTORY_UP(ptr, ptr_length)) {
 				char save;
 
+				if (use_relative_path) {
+					CWD_STATE_FREE(state);
+					*state = old_state;
+					return 1;
+				}
+
 				save = DEFAULT_SLASH;
 
 #define PREVIOUS state->cwd[state->cwd_length - 1]
@@ -609,33 +626,38 @@
 					state->cwd_length--;
 				}
 			} else if (!IS_DIRECTORY_CURRENT(ptr, ptr_length)) {
-				state->cwd = (char *) realloc(state->cwd, state->cwd_length+ptr_length+1+1);
+				if (use_relative_path) {
+					state->cwd = (char *) realloc(state->cwd, state->cwd_length+ptr_length+1);
+					use_relative_path = 0;
+				} else {
+					state->cwd = (char *) realloc(state->cwd, state->cwd_length+ptr_length+1+1);
 #ifdef TSRM_WIN32
-				/* Windows 9x will consider C:\\Foo as a network path. Avoid it. */
-				if (state->cwd_length < 2 ||
-				    (state->cwd[state->cwd_length-1]!='\\' && state->cwd[state->cwd_length-1]!='/') ||
-						IsDBCSLeadByte(state->cwd[state->cwd_length-2])) {
-					state->cwd[state->cwd_length++] = DEFAULT_SLASH;
-				}
+					/* Windows 9x will consider C:\\Foo as a network path. Avoid it. */
+					if (state->cwd_length < 2 ||
+					    (state->cwd[state->cwd_length-1]!='\\' && state->cwd[state->cwd_length-1]!='/') ||
+							IsDBCSLeadByte(state->cwd[state->cwd_length-2])) {
+						state->cwd[state->cwd_length++] = DEFAULT_SLASH;
+					}
 #elif defined(NETWARE)
-				/* 
-				Below code keeps appending to state->cwd a File system seperator
-				cases where this appending should not happen is given below,
-				a) sys: should just be left as it is
-				b) sys:system should just be left as it is,
-					Colon is allowed only in the first token as volume names alone can have the : in their names.
-					Files and Directories cannot have : in their names
-					So the check goes like this,
-					For second token and above simply append the DEFAULT_SLASH to the state->cwd.
-					For first token check for the existence of : 
-					if it exists don't append the DEFAULT_SLASH to the state->cwd.
-				*/
-				if(((state->cwd_length == 0) && (strchr(ptr, ':') == NULL)) || (state->cwd_length > 0)) {
-					state->cwd[state->cwd_length++] = DEFAULT_SLASH;
-				}
+					/* 
+					Below code keeps appending to state->cwd a File system seperator
+					cases where this appending should not happen is given below,
+					a) sys: should just be left as it is
+					b) sys:system should just be left as it is,
+						Colon is allowed only in the first token as volume names alone can have the : in their names.
+						Files and Directories cannot have : in their names
+						So the check goes like this,
+						For second token and above simply append the DEFAULT_SLASH to the state->cwd.
+						For first token check for the existence of : 
+						if it exists don't append the DEFAULT_SLASH to the state->cwd.
+					*/
+					if(((state->cwd_length == 0) && (strchr(ptr, ':') == NULL)) || (state->cwd_length > 0)) {
+						state->cwd[state->cwd_length++] = DEFAULT_SLASH;
+					}
 #else
-				state->cwd[state->cwd_length++] = DEFAULT_SLASH;
+					state->cwd[state->cwd_length++] = DEFAULT_SLASH;
 #endif
+				}
 				memcpy(&state->cwd[state->cwd_length], ptr, ptr_length+1);
 
 #ifdef TSRM_WIN32
@@ -652,14 +674,14 @@
 						memcpy(&state->cwd[state->cwd_length], data.cFileName, length+1);
 						ptr_length = length;
 						FindClose(hFind);
+						ret = 0;
 					} else if (use_realpath == CWD_REALPATH) {
 						if (is_unc) {
+							/* skip share name */
 							is_unc--;
+							ret = 0;
 						} else {
-							free(free_path);
-							CWD_STATE_FREE(state);
-							*state = old_state;					
-							return 1;
+							ret = 1;
 						}
 					}
 				}
@@ -672,6 +694,12 @@
 
 		free(free_path);
 
+		if ((use_realpath == CWD_REALPATH) && ret) {
+			CWD_STATE_FREE(state);
+			*state = old_state;					
+			return 1;
+		}
+
 		if (state->cwd_length == COPY_WHEN_ABSOLUTE(state->cwd)) {
 			state->cwd = (char *) realloc(state->cwd, state->cwd_length+1+1);
 			state->cwd[state->cwd_length] = DEFAULT_SLASH;
@@ -680,7 +708,7 @@
 		}
 	}
 
-	if (use_realpath != CWD_EXPAND && CWDG(realpath_cache_size_limit)) {
+	if (use_cache) {
 		realpath_cache_add(path, path_length, state->cwd, state->cwd_length, t TSRMLS_CC);
 	}
 
