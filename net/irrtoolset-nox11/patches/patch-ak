$NetBSD: patch-ak,v 1.2 2005/08/26 08:41:46 spz Exp $

--- src/Core/util/List.hh.orig	2004-07-30 12:58:10.000000000 +0200
+++ src/Core/util/List.hh
@@ -164,7 +164,7 @@ public:
 	ListIterator (const const_ListIterator<T>& cit) : const_ListIterator<T>(cit.list_, cit.ptr_) {}
 	ListIterator (const List<T> &l, ListNode *p=0) : const_ListIterator<T>(l, p?p:l.forw) {}
 
-	operator T* () const { return (ptr_==(ListNode*)list_) ? 0 : (T*)ptr_; }
+	operator T* () const { return (const_ListIterator<T>::ptr_==(ListNode*)const_ListIterator<T>::list_) ? 0 : (T*)const_ListIterator<T>::ptr_; }
 	T* operator-> () const { return (T*)const_ListIterator<T>::operator->(); }
 	ListIterator& operator++ () { // prefix ++
 		const_ListIterator<T>::operator++();
@@ -185,17 +185,17 @@ public:
 
 	const_ListSearchIterator& operator++ () { // prefix ++
 		for (const_ListIterator<T>::operator++();
-		     ptr_!=(ListNode*)list_;
+		     const_ListIterator<T>::ptr_!=(ListNode*)const_ListIterator<T>::list_;
 		     const_ListIterator<T>::operator++()) {
-			if (((T*)ptr_)->isKey(key_)) break;
+			if (((T*)const_ListIterator<T>::ptr_)->isKey(key_)) break;
 		}
 		return *this;
 	}
 	const_ListSearchIterator& operator-- () { // prefix --
 		for (const_ListIterator<T>::operator--();
-		     ptr_!=(ListNode*)list_;
+		     const_ListIterator<T>::ptr_!=(ListNode*)const_ListIterator<T>::list_;
 		     const_ListIterator<T>::operator--()) {
-			if (((T*)ptr_)->isKey(key_)) break;
+			if (((T*)const_ListIterator<T>::ptr_)->isKey(key_)) break;
 		}
 		return *this;
 	}
@@ -212,7 +212,7 @@ public:
 		: const_ListSearchIterator<T, Key>(k, l, p?p:(ListNode*)&l) {}
 	
 
-	operator T* () const { return (ptr_==(ListNode*)list_) ? 0 : (T*)ptr_; }
+	operator T* () const { return (const_ListIterator<T>::ptr_==(ListNode*)const_ListIterator<T>::list_) ? 0 : (T*)const_ListIterator<T>::ptr_; }
 	T* operator-> () const { return (T*)const_ListIterator<T>::operator->(); }
 	ListSearchIterator& operator++ () { // prefix ++
 		const_ListSearchIterator<T,Key>::operator++();
@@ -407,11 +407,11 @@ public:
 	 *      (A1 A2 A3) and (A4 B C), where A1==A2==A3==A4,
 	 *  will be equal. 
 	 */
-      if (length != b.length)
+      if (List<T>::length != b.length)
 	 return false;
 
       ListNode *e, *e2;
-      for (e = forw; e != (ListNode*)this; e = e->forw) {
+      for (e = List<T>::forw; e != (ListNode*)this; e = e->forw) {
 	 for (e2 = b.forw; e2 != (const ListNode*) &b; e2 = e2->forw)
 	    if (*(T*)e == *(T*)e2)
 	       break;
@@ -451,31 +451,31 @@ public:
      
    void insertSorted(T *t) {
       ListNode *e;
-      for (e = forw; e != (ListNode*)this && (*(T*)e < *t); e = e->forw)
+      for (e = List<T>::forw; e != (ListNode*)this && (*(T*)e < *t); e = e->forw)
 	 ;
 
       if (e != (ListNode*)this)
 	 t->__link__(e->back, e);
       else
-	 t->__link__(back, this);
+	 t->__link__(List<T>::back, this);
 
-      length++;
+      List<T>::length++;
    }
 
    bool insertSortedNoDups(T *t) {
       ListNode *e;
-      for (e = forw; e != (ListNode*)this && (*(T*)e < *t); e = e->forw)
+      for (e = List<T>::forw; e != (ListNode*)this && (*(T*)e < *t); e = e->forw)
 	 ;
       
       if (e != (ListNode*)this) {
 	 if (!(*(T*)e == *t)) {
 	    t->__link__(e->back, e);
-	    length++;
+	    List<T>::length++;
 	    return true;
 	 }
       } else {
-	 t->__link__(back, this);
-	 length++;
+	 t->__link__(List<T>::back, this);
+	 List<T>::length++;
 	    return true;
       }
       return false;
@@ -484,7 +484,7 @@ public:
    // do a sorted merge
    void splice(SortedList& l) {
       ListNode *t;
-      ListNode *e = forw;
+      ListNode *e = List<T>::forw;
       while (!l.isEmpty()) {
 	 t = l.forw;
 	 t->__unlink__();
@@ -495,16 +495,16 @@ public:
 	 if (e != (ListNode*)this)
 	    t->__link__(e->back, e);
 	 else
-	    t->__link__(back, this);
+	    t->__link__(List<T>::back, this);
       }
 
-      length += l.length;
+      List<T>::length += l.length;
    }
 
    // do a sorted merge
    void splice(List<T>& l) {
       ListNode *t;
-      ListNode *e = forw;
+      ListNode *e = List<T>::forw;
       while (!l.isEmpty()) {
 	 t = l.forw;
 	 t->__unlink__();
@@ -514,7 +514,7 @@ public:
    // sorted merge no dups
    void spliceNoDups(SortedList& l) {
       ListNode *t;
-      ListNode *e = forw;
+      ListNode *e = List<T>::forw;
       while (!l.isEmpty()) {
    t = l.forw;
    t->__unlink__();
@@ -527,16 +527,16 @@ public:
         t->__link__(e->back, e);
    }
    else
-      t->__link__(back, this);
+      t->__link__(List<T>::back, this);
       }
 
-      length += l.length;
+      List<T>::length += l.length;
    }
   
   
 
    T* find(const T &t) const {
-      for (ListNode *e = forw; e != (const ListNode*)this; e = e->forw)
+      for (ListNode *e = List<T>::forw; e != (const ListNode*)this; e = e->forw)
 	 if (*(T*)e == t)
 		 return (T*)e;
 	 else if (!(*(T*)e < t))
@@ -572,37 +572,37 @@ public:
    }
 
    WRRListIterator& operator++ () { // prefix ++
-      ListNode *position = ptr_;
+      ListNode *position = ListIterator<T>::ptr_;
 
       for (ListIterator<T>::operator++ (); 
 	   *this; 
 	   ListIterator<T>::operator++ ())
-	 if ((*uniform_)() < ((T *) ptr_)->weight())
+	 if ((*uniform_)() < ((T *) ListIterator<T>::ptr_)->weight())
 	    return *this;
 
       // we do this twice to handle circular queue
       for (ListIterator<T>::operator++ (); 
-	   ptr_ != position; 
+	   ListIterator<T>::ptr_ != position; 
 	   ListIterator<T>::operator++ ())
-	 if ((*uniform_)() < ((T *) ptr_)->weight())
+	 if ((*uniform_)() < ((T *) ListIterator<T>::ptr_)->weight())
 	    return *this;
       return *this;
    }
 
    WRRListIterator& operator-- () { // prefix --
-      ListNode *position = ptr_;
+      ListNode *position = ListIterator<T>::ptr_;
 
       for (ListIterator<T>::operator-- (); 
 	   *this; 
 	   ListIterator<T>::operator-- ())
-	 if ((*uniform_)() < ((T *) ptr_)->weight())
+	 if ((*uniform_)() < ((T *) ListIterator<T>::ptr_)->weight())
 	    return *this;
 
       // we do this twice to handle circular queue
       for (ListIterator<T>::operator-- (); 
-	   ptr_ != position; 
+	   ListIterator<T>::ptr_ != position; 
 	   ListIterator<T>::operator-- ())
-	 if ((*uniform_)() < ((T *) ptr_)->weight())
+	 if ((*uniform_)() < ((T *) ListIterator<T>::ptr_)->weight())
 	    return *this;
       return *this;
    }
